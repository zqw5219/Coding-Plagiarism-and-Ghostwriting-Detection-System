originalCode,typeIndicator,pureCode,pureComment,pureMacro
/*,1.0,,/*,
* tsh - A tiny shell program with job control,1.0,,* tsh - A tiny shell program with job control,
*,1.0,,*,
* Name: Yuan Fu,1.0,,* Name: Yuan Fu,
* ID:   ykf5041,1.0,,* ID:   ykf5041,
*/,0.0,*/,,
#include <stdio.h>,0.0,#include <stdio.h>,,
#include <stdlib.h>,0.0,#include <stdlib.h>,,
#include <unistd.h>,0.0,#include <unistd.h>,,
#include <string.h>,0.0,#include <string.h>,,
#include <ctype.h>,0.0,#include <ctype.h>,,
#include <signal.h>,0.0,#include <signal.h>,,
#include <sys/types.h>,0.0,#include <sys/types.h>,,
#include <sys/wait.h>,0.0,#include <sys/wait.h>,,
#include <errno.h>,0.0,#include <errno.h>,,
,0.0,,,
/* Misc manifest constants */,1.0,,/* Misc manifest constants */,
#define MAXLINE    1024   /* max line size */,1.0,,#define MAXLINE    1024   /* max line size */,
#define MAXARGS     128   /* max args on a command line */,1.0,,#define MAXARGS     128   /* max args on a command line */,
#define MAXJOBS      16   /* max jobs at any point in time */,1.0,,#define MAXJOBS      16   /* max jobs at any point in time */,
#define MAXJID    1<<16   /* max job ID */,1.0,,#define MAXJID    1<<16   /* max job ID */,
,0.0,,,
/* Job states */,1.0,,/* Job states */,
#define UNDEF 0 /* undefined */,1.0,,#define UNDEF 0 /* undefined */,
#define FG 1    /* running in foreground */,1.0,,#define FG 1    /* running in foreground */,
#define BG 2    /* running in background */,1.0,,#define BG 2    /* running in background */,
#define ST 3    /* stopped */,1.0,,#define ST 3    /* stopped */,
,0.0,,,
/*,1.0,,/*,
"* Jobs states: FG (foreground), BG (background), ST (stopped)",1.0,,"* Jobs states: FG (foreground), BG (background), ST (stopped)",
* Job state transitions and enabling actions:,1.0,,* Job state transitions and enabling actions:,
*     FG -> ST  : ctrl-z,1.0,,*     FG -> ST  : ctrl-z,
*     ST -> FG  : fg command,1.0,,*     ST -> FG  : fg command,
*     ST -> BG  : bg command,1.0,,*     ST -> BG  : bg command,
*     BG -> FG  : fg command,1.0,,*     BG -> FG  : fg command,
* At most 1 job can be in the FG state.,1.0,,* At most 1 job can be in the FG state.,
*/,0.0,*/,,
,0.0,,,
/* Global variables */,1.0,,/* Global variables */,
extern char **environ;      /* defined in libc */,1.0,,extern char **environ;      /* defined in libc */,
"char prompt[] = ""tsh> "";    /* command line prompt (DO NOT CHANGE) */",1.0,,"char prompt[] = ""tsh> "";    /* command line prompt (DO NOT CHANGE) */",
"int verbose = 0;            /* if true, print additional output */",1.0,,"int verbose = 0;            /* if true, print additional output */",
int nextjid = 1;            /* next job ID to allocate */,1.0,,int nextjid = 1;            /* next job ID to allocate */,
char sbuf[MAXLINE];         /* for composing sprintf messages */,1.0,,char sbuf[MAXLINE];         /* for composing sprintf messages */,
,0.0,,,
struct job_t {              /* The job struct */,1.0,,struct job_t {              /* The job struct */,
pid_t pid;              /* job PID */,1.0,,pid_t pid;              /* job PID */,
"int jid;                /* job ID [1, 2, ...] */",1.0,,"int jid;                /* job ID [1, 2, ...] */",
"int state;              /* UNDEF, BG, FG, or ST */",1.0,,"int state;              /* UNDEF, BG, FG, or ST */",
char cmdline[MAXLINE];  /* command line */,1.0,,char cmdline[MAXLINE];  /* command line */,
};,0.0,};,,
struct job_t jobs[MAXJOBS]; /* The job list */,1.0,,struct job_t jobs[MAXJOBS]; /* The job list */,
/* End global variables */,1.0,,/* End global variables */,
,0.0,,,
,0.0,,,
/* Function prototypes */,1.0,,/* Function prototypes */,
,0.0,,,
/* Here are the functions that you will implement */,1.0,,/* Here are the functions that you will implement */,
void eval(char *cmdline);,0.0,void eval(char *cmdline);,,
int builtin_cmd(char **argv);,0.0,int builtin_cmd(char **argv);,,
void do_bgfg(char **argv);,0.0,void do_bgfg(char **argv);,,
void waitfg(pid_t pid);,0.0,void waitfg(pid_t pid);,,
,0.0,,,
void sigchld_handler(int sig);,0.0,void sigchld_handler(int sig);,,
void sigtstp_handler(int sig);,0.0,void sigtstp_handler(int sig);,,
void sigint_handler(int sig);,0.0,void sigint_handler(int sig);,,
,0.0,,,
/* Here are helper routines that we've provided for you */,1.0,,/* Here are helper routines that we've provided for you */,
"int parseline(const char *cmdline, char **argv);",0.0,"int parseline(const char *cmdline, char **argv);",,
void sigquit_handler(int sig);,0.0,void sigquit_handler(int sig);,,
,0.0,,,
void clearjob(struct job_t *job);,0.0,void clearjob(struct job_t *job);,,
void initjobs(struct job_t *jobs);,0.0,void initjobs(struct job_t *jobs);,,
int maxjid(struct job_t *jobs);,0.0,int maxjid(struct job_t *jobs);,,
"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);",0.0,"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);",,
"int deletejob(struct job_t *jobs, pid_t pid);",0.0,"int deletejob(struct job_t *jobs, pid_t pid);",,
pid_t fgpid(struct job_t *jobs);,0.0,pid_t fgpid(struct job_t *jobs);,,
"struct job_t *getjobpid(struct job_t *jobs, pid_t pid);",0.0,"struct job_t *getjobpid(struct job_t *jobs, pid_t pid);",,
"struct job_t *getjobjid(struct job_t *jobs, int jid);",0.0,"struct job_t *getjobjid(struct job_t *jobs, int jid);",,
int pid2jid(pid_t pid);,0.0,int pid2jid(pid_t pid);,,
void listjobs(struct job_t *jobs);,0.0,void listjobs(struct job_t *jobs);,,
,0.0,,,
void usage(void);,0.0,void usage(void);,,
void unix_error(char *msg);,0.0,void unix_error(char *msg);,,
void app_error(char *msg);,0.0,void app_error(char *msg);,,
typedef void handler_t(int);,0.0,typedef void handler_t(int);,,
"handler_t *Signal(int signum, handler_t *handler);",0.0,"handler_t *Signal(int signum, handler_t *handler);",,
,0.0,,,
/* my helpers */,1.0,,/* my helpers */,
,0.0,,,
pid_t Fork(void);,0.0,pid_t Fork(void);,,
"void Kill(pid_t pid, int signum);",0.0,"void Kill(pid_t pid, int signum);",,
"void Setpgid(pid_t pid, pid_t pgid);",0.0,"void Setpgid(pid_t pid, pid_t pgid);",,
"void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset);",0.0,"void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset);",,
void Sigemptyset(sigset_t *set);,0.0,void Sigemptyset(sigset_t *set);,,
void Sigfillset(sigset_t *set);,0.0,void Sigfillset(sigset_t *set);,,
"void Sigaddset(sigset_t *set, int signum);",0.0,"void Sigaddset(sigset_t *set, int signum);",,
"void sh_execve(const char *filename, char *const argv[], char *const envp[]);",0.0,"void sh_execve(const char *filename, char *const argv[], char *const envp[]);",,
sigset_t sigchld_mask ();,0.0,sigset_t sigchld_mask ();,,
void put_fg(struct job_t *job);,0.0,void put_fg(struct job_t *job);,,
void bg_cont(struct job_t *job);,0.0,void bg_cont(struct job_t *job);,,
void print_bg_job(struct job_t *job);,0.0,void print_bg_job(struct job_t *job);,,
,0.0,,,
/*,1.0,,/*,
* main - The shell's main routine,1.0,,* main - The shell's main routine,
*/,0.0,*/,,
"int main(int argc, char **argv)",0.0,"int main(int argc, char **argv)",,
{,0.0,{,,
char c;,0.0,char c;,,
char cmdline[MAXLINE];,0.0,char cmdline[MAXLINE];,,
int emit_prompt = 1; /* emit prompt (default) */,1.0,,int emit_prompt = 1; /* emit prompt (default) */,
,0.0,,,
/* Redirect stderr to stdout (so that driver will get all output,1.0,,/* Redirect stderr to stdout (so that driver will get all output,
* on the pipe connected to stdout) */,0.0,* on the pipe connected to stdout) */,,
"dup2(1, 2);",0.0,"dup2(1, 2);",,
,0.0,,,
/* Parse the command line */,1.0,,/* Parse the command line */,
"while ((c = getopt(argc, argv, ""hvp"")) != EOF) {",0.0,"while ((c = getopt(argc, argv, ""hvp"")) != EOF) {",,
switch (c) {,0.0,switch (c) {,,
case 'h':             /* print help message */,1.0,,case 'h':             /* print help message */,
usage();,0.0,usage();,,
break;,0.0,break;,,
case 'v':             /* emit additional diagnostic info */,1.0,,case 'v':             /* emit additional diagnostic info */,
verbose = 1;,0.0,verbose = 1;,,
break;,0.0,break;,,
case 'p':             /* don't print a prompt */,1.0,,case 'p':             /* don't print a prompt */,
emit_prompt = 0;  /* handy for automatic testing */,1.0,,emit_prompt = 0;  /* handy for automatic testing */,
break;,0.0,break;,,
default:,0.0,default:,,
usage();,0.0,usage();,,
},0.0,},,
},0.0,},,
,0.0,,,
/* Install the signal handlers */,1.0,,/* Install the signal handlers */,
,0.0,,,
/* These are the ones you will need to implement */,1.0,,/* These are the ones you will need to implement */,
"Signal(SIGINT,  sigint_handler);   /* ctrl-c */",1.0,,"Signal(SIGINT,  sigint_handler);   /* ctrl-c */",
"Signal(SIGTSTP, sigtstp_handler);  /* ctrl-z */",1.0,,"Signal(SIGTSTP, sigtstp_handler);  /* ctrl-z */",
"Signal(SIGCHLD, sigchld_handler);  /* Terminated or stopped child */",1.0,,"Signal(SIGCHLD, sigchld_handler);  /* Terminated or stopped child */",
,0.0,,,
/* This one provides a clean way to kill the shell */,1.0,,/* This one provides a clean way to kill the shell */,
"Signal(SIGQUIT, sigquit_handler);",0.0,"Signal(SIGQUIT, sigquit_handler);",,
,0.0,,,
/* Initialize the job list */,1.0,,/* Initialize the job list */,
initjobs(jobs);,0.0,initjobs(jobs);,,
,0.0,,,
/* Execute the shell's read/eval loop */,1.0,,/* Execute the shell's read/eval loop */,
while (1) {,0.0,while (1) {,,
,0.0,,,
/* Read command line */,1.0,,/* Read command line */,
if (emit_prompt) {,0.0,if (emit_prompt) {,,
"printf(""%s"", prompt);",0.0,"printf(""%s"", prompt);",,
fflush(stdout);,0.0,fflush(stdout);,,
},0.0,},,
"if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))",0.0,"if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))",,
"app_error(""fgets error"");",0.0,"app_error(""fgets error"");",,
if (feof(stdin)) { /* End of file (ctrl-d) */,1.0,,if (feof(stdin)) { /* End of file (ctrl-d) */,
fflush(stdout);,0.0,fflush(stdout);,,
exit(0);,0.0,exit(0);,,
},0.0,},,
,0.0,,,
/* Evaluate the command line */,1.0,,/* Evaluate the command line */,
eval(cmdline);,0.0,eval(cmdline);,,
fflush(stdout);,0.0,fflush(stdout);,,
fflush(stdout);,0.0,fflush(stdout);,,
},0.0,},,
,0.0,,,
exit(0); /* control never reaches here */,1.0,,exit(0); /* control never reaches here */,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* eval - Evaluate the command line that the user has just typed in,1.0,,* eval - Evaluate the command line that the user has just typed in,
*,1.0,,*,
"* If the user has requested a built-in command (quit, jobs, bg or fg)",1.0,,"* If the user has requested a built-in command (quit, jobs, bg or fg)",
"* then execute it immediately. Otherwise, fork a child process and",1.0,,"* then execute it immediately. Otherwise, fork a child process and",
* run the job in the context of the child. If the job is running in,1.0,,* run the job in the context of the child. If the job is running in,
"* the foreground, wait for it to terminate and then return.  Note:",1.0,,"* the foreground, wait for it to terminate and then return.  Note:",
* each child process must have a unique process group ID so that our,1.0,,* each child process must have a unique process group ID so that our,
* background children don't receive SIGINT (SIGTSTP) from the kernel,1.0,,* background children don't receive SIGINT (SIGTSTP) from the kernel,
* when we type ctrl-c (ctrl-z) at the keyboard.,1.0,,* when we type ctrl-c (ctrl-z) at the keyboard.,
*/,0.0,*/,,
void eval(char *cmdline),0.0,void eval(char *cmdline),,
{,0.0,{,,
char *argv[MAXARGS];,0.0,char *argv[MAXARGS];,,
char buf[MAXLINE];,0.0,char buf[MAXLINE];,,
int bg;,0.0,int bg;,,
pid_t ret_pid;,0.0,pid_t ret_pid;,,
int state;,0.0,int state;,,
,0.0,,,
"strcpy(buf, cmdline);",0.0,"strcpy(buf, cmdline);",,
"bg = parseline(buf, argv);",0.0,"bg = parseline(buf, argv);",,
if (bg),0.0,if (bg),,
state = BG;,0.0,state = BG;,,
else,0.0,else,,
state = FG;,0.0,state = FG;,,
,0.0,,,
// ignore empty lines,0.5,,// ignore empty lines,
if (argv[0] == NULL),0.0,if (argv[0] == NULL),,
return;,0.0,return;,,
,0.0,,,
// fork child,0.5,,// fork child,
if (builtin_cmd(argv) == 0) {,0.0,if (builtin_cmd(argv) == 0) {,,
sigset_t mask = sigchld_mask();,0.0,sigset_t mask = sigchld_mask();,,
"Sigprocmask(SIG_BLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_BLOCK, &mask, NULL);",,
ret_pid = Fork();,0.0,ret_pid = Fork();,,
if (ret_pid == 0) {,0.0,if (ret_pid == 0) {,,
// child,0.5,,// child,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
// put child in a new process group,0.5,,// put child in a new process group,
"Setpgid(0, 0);",0.0,"Setpgid(0, 0);",,
// TODO handle command not found & job ist,0.5,,// TODO handle command not found & job ist,
"sh_execve(argv[0], argv, environ);",0.0,"sh_execve(argv[0], argv, environ);",,
} else {,0.0,} else {,,
// parent,0.5,,// parent,
"addjob(jobs, ret_pid, state, cmdline);",0.0,"addjob(jobs, ret_pid, state, cmdline);",,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
if (state == FG) {,0.0,if (state == FG) {,,
waitfg(ret_pid);,0.0,waitfg(ret_pid);,,
} else {,0.0,} else {,,
"struct job_t *job = getjobpid(jobs, ret_pid);",0.0,"struct job_t *job = getjobpid(jobs, ret_pid);",,
if (job != NULL),0.0,if (job != NULL),,
print_bg_job(job);,0.0,print_bg_job(job);,,
else,0.0,else,,
"unix_error(""Eval error: job is NULL??"");",0.0,"unix_error(""Eval error: job is NULL??"");",,
},0.0,},,
},0.0,},,
},0.0,},,
// wait for child to terminate if foreground,0.5,,// wait for child to terminate if foreground,
,0.0,,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* parseline - Parse the command line and build the argv array.,1.0,,* parseline - Parse the command line and build the argv array.,
*,1.0,,*,
* Characters enclosed in single quotes are treated as a single,1.0,,* Characters enclosed in single quotes are treated as a single,
"* argument.  Return true if the user has requested a BG job, false if",1.0,,"* argument.  Return true if the user has requested a BG job, false if",
* the user has requested a FG job.,1.0,,* the user has requested a FG job.,
*/,0.0,*/,,
"int parseline(const char *cmdline, char **argv)",0.0,"int parseline(const char *cmdline, char **argv)",,
{,0.0,{,,
static char array[MAXLINE]; /* holds local copy of command line */,1.0,,static char array[MAXLINE]; /* holds local copy of command line */,
char *buf = array;          /* ptr that traverses command line */,1.0,,char *buf = array;          /* ptr that traverses command line */,
char *delim;                /* points to first space delimiter */,1.0,,char *delim;                /* points to first space delimiter */,
int argc;                   /* number of args */,1.0,,int argc;                   /* number of args */,
int bg;                     /* background job? */,1.0,,int bg;                     /* background job? */,
,0.0,,,
"strcpy(buf, cmdline);",0.0,"strcpy(buf, cmdline);",,
buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */,1.0,,buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */,
while (*buf && (*buf == ' ')) /* ignore leading spaces */,1.0,,while (*buf && (*buf == ' ')) /* ignore leading spaces */,
buf++;,0.0,buf++;,,
,0.0,,,
/* Build the argv list */,1.0,,/* Build the argv list */,
argc = 0;,0.0,argc = 0;,,
if (*buf == '\'') {,0.0,if (*buf == '\'') {,,
buf++;,0.0,buf++;,,
"delim = strchr(buf, '\'');",0.0,"delim = strchr(buf, '\'');",,
},0.0,},,
else {,0.0,else {,,
"delim = strchr(buf, ' ');",0.0,"delim = strchr(buf, ' ');",,
},0.0,},,
,0.0,,,
while (argc < MAXARGS-1 && delim) {,0.0,while (argc < MAXARGS-1 && delim) {,,
argv[argc++] = buf;,0.0,argv[argc++] = buf;,,
*delim = '\0';,0.0,*delim = '\0';,,
buf = delim + 1;,0.0,buf = delim + 1;,,
while (*buf && (*buf == ' ')) /* ignore spaces */,1.0,,while (*buf && (*buf == ' ')) /* ignore spaces */,
buf++;,0.0,buf++;,,
,0.0,,,
if (*buf == '\'') {,0.0,if (*buf == '\'') {,,
buf++;,0.0,buf++;,,
"delim = strchr(buf, '\'');",0.0,"delim = strchr(buf, '\'');",,
},0.0,},,
else {,0.0,else {,,
"delim = strchr(buf, ' ');",0.0,"delim = strchr(buf, ' ');",,
},0.0,},,
},0.0,},,
if (delim) {,0.0,if (delim) {,,
"fprintf(stderr, ""Too many arguments.\n"");",0.0,"fprintf(stderr, ""Too many arguments.\n"");",,
argc = 0; //treat it as an empty line.,0.5,argc = 0; ,//treat it as an empty line.,
},0.0,},,
argv[argc] = NULL;,0.0,argv[argc] = NULL;,,
,0.0,,,
if (argc == 0)  /* ignore blank line */,1.0,,if (argc == 0)  /* ignore blank line */,
return 1;,0.0,return 1;,,
,0.0,,,
/* should the job run in the background? */,1.0,,/* should the job run in the background? */,
if ((bg = (*argv[argc-1] == '&')) != 0) {,0.0,if ((bg = (*argv[argc-1] == '&')) != 0) {,,
argv[--argc] = NULL;,0.0,argv[--argc] = NULL;,,
},0.0,},,
return bg;,0.0,return bg;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* builtin_cmd - If the user has typed a built-in command then execute,1.0,,* builtin_cmd - If the user has typed a built-in command then execute,
*    it immediately.,1.0,,*    it immediately.,
*/,0.0,*/,,
int builtin_cmd(char **argv),0.0,int builtin_cmd(char **argv),,
{,0.0,{,,
char *cmd = argv[0];,0.0,char *cmd = argv[0];,,
,0.0,,,
"if (strcmp(cmd, ""fg"") == 0) {",0.0,"if (strcmp(cmd, ""fg"") == 0) {",,
do_bgfg(argv);,0.0,do_bgfg(argv);,,
return 1;,0.0,return 1;,,
"} else if (strcmp(cmd, ""bg"") == 0) {",0.0,"} else if (strcmp(cmd, ""bg"") == 0) {",,
do_bgfg(argv);,0.0,do_bgfg(argv);,,
return 1;,0.0,return 1;,,
"} else if (strcmp(cmd, ""quit"") == 0) {",0.0,"} else if (strcmp(cmd, ""quit"") == 0) {",,
exit(0);,0.0,exit(0);,,
"} else if (strcmp(cmd, ""jobs"") == 0) {",0.0,"} else if (strcmp(cmd, ""jobs"") == 0) {",,
sigset_t mask = sigchld_mask();,0.0,sigset_t mask = sigchld_mask();,,
"Sigprocmask(SIG_BLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_BLOCK, &mask, NULL);",,
listjobs(jobs);,0.0,listjobs(jobs);,,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
return 1;,0.0,return 1;,,
},0.0,},,
return 0;     /* not a builtin command */,1.0,,return 0;     /* not a builtin command */,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* do_bgfg - Execute the builtin bg and fg commands,1.0,,* do_bgfg - Execute the builtin bg and fg commands,
*/,0.0,*/,,
void do_bgfg(char **argv),0.0,void do_bgfg(char **argv),,
{,0.0,{,,
char *cmd = argv[0];,0.0,char *cmd = argv[0];,,
int jid;,0.0,int jid;,,
int jid_scan;,0.0,int jid_scan;,,
int pid;,0.0,int pid;,,
int pid_scan;,0.0,int pid_scan;,,
char *job_num = argv[1];,0.0,char *job_num = argv[1];,,
struct job_t *job;,0.0,struct job_t *job;,,
"int fg = strcmp(cmd, ""fg"") == 0;",0.0,"int fg = strcmp(cmd, ""fg"") == 0;",,
"int bg = strcmp(cmd, ""bg"") == 0;",0.0,"int bg = strcmp(cmd, ""bg"") == 0;",,
,0.0,,,
// error checking,0.5,,// error checking,
if (job_num == NULL) {,0.0,if (job_num == NULL) {,,
if (fg),0.0,if (fg),,
"printf(""fg command requires PID or %%jobid argument\n"");",0.0,"printf(""fg command requires PID or %%jobid argument\n"");",,
else if (bg),0.0,else if (bg),,
"printf(""bg command requires PID or %%jobid argument\n"");",0.0,"printf(""bg command requires PID or %%jobid argument\n"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
// parse jid/pid,0.5,,// parse jid/pid,
"jid_scan = sscanf(job_num, ""%%%d"", &jid);",0.0,"jid_scan = sscanf(job_num, ""%%%d"", &jid);",,
"pid_scan = sscanf(job_num, ""%d"", &pid);",0.0,"pid_scan = sscanf(job_num, ""%d"", &pid);",,
if (jid_scan != 1 && pid_scan != 1) {,0.0,if (jid_scan != 1 && pid_scan != 1) {,,
if (fg),0.0,if (fg),,
"printf(""fg: argument must be a PID or %%jobid\n"");",0.0,"printf(""fg: argument must be a PID or %%jobid\n"");",,
else if (bg),0.0,else if (bg),,
"printf(""bg: argument must be a PID or %%jobid\n"");",0.0,"printf(""bg: argument must be a PID or %%jobid\n"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
// protect job list from sigchld_handler,0.5,,// protect job list from sigchld_handler,
sigset_t mask = sigchld_mask();,0.0,sigset_t mask = sigchld_mask();,,
"Sigprocmask(SIG_BLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_BLOCK, &mask, NULL);",,
,0.0,,,
// get job,0.5,,// get job,
if (jid_scan) {,0.0,if (jid_scan) {,,
"job = getjobjid(jobs, jid);",0.0,"job = getjobjid(jobs, jid);",,
if (job == NULL) {,0.0,if (job == NULL) {,,
"printf(""%%%d: No such job\n"", jid);",0.0,"printf(""%%%d: No such job\n"", jid);",,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
return;,0.0,return;,,
},0.0,},,
} else {,0.0,} else {,,
"job = getjobpid(jobs, pid);",0.0,"job = getjobpid(jobs, pid);",,
if (job == NULL) {,0.0,if (job == NULL) {,,
"printf(""(%d): No such process\n"", pid);",0.0,"printf(""(%d): No such process\n"", pid);",,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
return;,0.0,return;,,
},0.0,},,
},0.0,},,
// do work,0.5,,// do work,
if (fg),0.0,if (fg),,
put_fg(job);,0.0,put_fg(job);,,
else if (bg),0.0,else if (bg),,
bg_cont(job);,0.0,bg_cont(job);,,
,0.0,,,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* waitfg - Block until process pid is no longer the foreground process,1.0,,* waitfg - Block until process pid is no longer the foreground process,
*/,0.0,*/,,
void waitfg(pid_t pid),0.0,void waitfg(pid_t pid),,
{,0.0,{,,
sigset_t mask = sigchld_mask();,0.0,sigset_t mask = sigchld_mask();,,
"Sigprocmask(SIG_BLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_BLOCK, &mask, NULL);",,
"struct job_t *job = getjobpid(jobs, pid);",0.0,"struct job_t *job = getjobpid(jobs, pid);",,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
// if the foreground process died,0.5,,// if the foreground process died,
// it is cleared in the job list by signal handler,0.5,,// it is cleared in the job list by signal handler,
"// if it stopped, the state change",0.5,,"// if it stopped, the state change",
while (job != NULL && job->state == FG),0.0,while (job != NULL && job->state == FG),,
// 100000 micro second = 0.1s,0.5,,// 100000 micro second = 0.1s,
usleep(100000);,0.0,usleep(100000);,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*****************,1.0,,/*****************,
* Signal handlers,1.0,,* Signal handlers,
*****************/,0.0,*****************/,,
,0.0,,,
/*,1.0,,/*,
* sigchld_handler - The kernel sends a SIGCHLD to the shell whenever,1.0,,* sigchld_handler - The kernel sends a SIGCHLD to the shell whenever,
"*     a child job terminates (becomes a zombie), or stops because it",1.0,,"*     a child job terminates (becomes a zombie), or stops because it",
*     received a SIGSTOP or SIGTSTP signal. The handler reaps all,1.0,,*     received a SIGSTOP or SIGTSTP signal. The handler reaps all,
"*     available zombie children, but doesn't wait for any other",1.0,,"*     available zombie children, but doesn't wait for any other",
*     currently running children to terminate.,1.0,,*     currently running children to terminate.,
*/,0.0,*/,,
void sigchld_handler(int sig),0.0,void sigchld_handler(int sig),,
{,0.0,{,,
// reap children and delete jobs,0.5,,// reap children and delete jobs,
// this is the only handler that alters the job list,0.5,,// this is the only handler that alters the job list,
int status;,0.0,int status;,,
pid_t ret_pid;,0.0,pid_t ret_pid;,,
struct job_t *job;,0.0,struct job_t *job;,,
,0.0,,,
"while ((ret_pid = waitpid((pid_t) -1, &status, WNOHANG | WUNTRACED | WCONTINUED)) > 0) {",0.0,"while ((ret_pid = waitpid((pid_t) -1, &status, WNOHANG | WUNTRACED | WCONTINUED)) > 0) {",,
"job = getjobpid(jobs, ret_pid);",0.0,"job = getjobpid(jobs, ret_pid);",,
if (job != NULL) {,0.0,if (job != NULL) {,,
if (WIFSTOPPED(status)) {,0.0,if (WIFSTOPPED(status)) {,,
// stopped,0.5,,// stopped,
"printf(""Job [%d] (%d) stopped by signal %d\n"", job->jid, job->pid, WSTOPSIG(status));",0.0,"printf(""Job [%d] (%d) stopped by signal %d\n"", job->jid, job->pid, WSTOPSIG(status));",,
job->state = ST;,0.0,job->state = ST;,,
} else if (WIFEXITED(status)) {,0.0,} else if (WIFEXITED(status)) {,,
// delete job without printing,0.5,,// delete job without printing,
"deletejob(jobs, ret_pid);",0.0,"deletejob(jobs, ret_pid);",,
} else if (WIFSIGNALED(status)) {,0.0,} else if (WIFSIGNALED(status)) {,,
// terminated,0.5,,// terminated,
// only print message when terminated by a signal,0.5,,// only print message when terminated by a signal,
"printf(""Job [%d] (%d) terminated by signal %d\n"", job->jid, job->pid, WTERMSIG(status));",0.0,"printf(""Job [%d] (%d) terminated by signal %d\n"", job->jid, job->pid, WTERMSIG(status));",,
"deletejob(jobs, ret_pid);",0.0,"deletejob(jobs, ret_pid);",,
} else if (WIFCONTINUED(status)) {,0.0,} else if (WIFCONTINUED(status)) {,,
// update job state,0.5,,// update job state,
if (job->state != FG),0.0,if (job->state != FG),,
job->state = BG;,0.0,job->state = BG;,,
},0.0,},,
} else,0.0,} else,,
"unix_error(""Job not found in SIGCHLD handler"");",0.0,"unix_error(""Job not found in SIGCHLD handler"");",,
},0.0,},,
// return 0 is normal,0.5,,// return 0 is normal,
if (ret_pid != 0 && errno != ECHILD),0.0,if (ret_pid != 0 && errno != ECHILD),,
"unix_error(""waitpid error in signal handler"");",0.0,"unix_error(""waitpid error in signal handler"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigint_handler - The kernel sends a SIGINT to the shell whenver the,1.0,,* sigint_handler - The kernel sends a SIGINT to the shell whenver the,
*    user types ctrl-c at the keyboard.  Catch it and send it along,1.0,,*    user types ctrl-c at the keyboard.  Catch it and send it along,
*    to the foreground job.,1.0,,*    to the foreground job.,
*/,0.0,*/,,
void sigint_handler(int sig),0.0,void sigint_handler(int sig),,
{,0.0,{,,
pid_t pid = fgpid(jobs);,0.0,pid_t pid = fgpid(jobs);,,
if (pid != 0),0.0,if (pid != 0),,
// negative means send to whole group,0.5,,// negative means send to whole group,
"Kill(-pid, SIGINT);",0.0,"Kill(-pid, SIGINT);",,
// else,0.5,,// else,
// no foreground process,0.5,,// no foreground process,
"// too bad, ima stick around",0.5,,"// too bad, ima stick around",
// exit(0);,0.5,,// exit(0);,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever,1.0,,* sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever,
*     the user types ctrl-z at the keyboard. Catch it and suspend the,1.0,,*     the user types ctrl-z at the keyboard. Catch it and suspend the,
*     foreground job by sending it a SIGTSTP.,1.0,,*     foreground job by sending it a SIGTSTP.,
*/,0.0,*/,,
void sigtstp_handler(int sig),0.0,void sigtstp_handler(int sig),,
{,0.0,{,,
pid_t pid = fgpid(jobs);,0.0,pid_t pid = fgpid(jobs);,,
if (pid != 0),0.0,if (pid != 0),,
// keep this handler pure and let sigchld_handler,0.5,,// keep this handler pure and let sigchld_handler,
// mungo with job list,0.5,,// mungo with job list,
"Kill(-pid, SIGTSTP);",0.0,"Kill(-pid, SIGTSTP);",,
"// if no foreground process, do nothing",0.5,,"// if no foreground process, do nothing",
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*********************,1.0,,/*********************,
* End signal handlers,1.0,,* End signal handlers,
*********************/,0.0,*********************/,,
,0.0,,,
/***********************************************,1.0,,/***********************************************,
* Helper routines that manipulate the job list,1.0,,* Helper routines that manipulate the job list,
**********************************************/,0.0,**********************************************/,,
,0.0,,,
/* clearjob - Clear the entries in a job struct */,1.0,,/* clearjob - Clear the entries in a job struct */,
void clearjob(struct job_t *job) {,0.0,void clearjob(struct job_t *job) {,,
job->pid = 0;,0.0,job->pid = 0;,,
job->jid = 0;,0.0,job->jid = 0;,,
job->state = UNDEF;,0.0,job->state = UNDEF;,,
job->cmdline[0] = '\0';,0.0,job->cmdline[0] = '\0';,,
},0.0,},,
,0.0,,,
/* initjobs - Initialize the job list */,1.0,,/* initjobs - Initialize the job list */,
void initjobs(struct job_t *jobs) {,0.0,void initjobs(struct job_t *jobs) {,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
clearjob(&jobs[i]);,0.0,clearjob(&jobs[i]);,,
},0.0,},,
,0.0,,,
/* maxjid - Returns largest allocated job ID */,1.0,,/* maxjid - Returns largest allocated job ID */,
int maxjid(struct job_t *jobs),0.0,int maxjid(struct job_t *jobs),,
{,0.0,{,,
"int i, max=0;",0.0,"int i, max=0;",,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].jid > max),0.0,if (jobs[i].jid > max),,
max = jobs[i].jid;,0.0,max = jobs[i].jid;,,
return max;,0.0,return max;,,
},0.0,},,
,0.0,,,
/* addjob - Add a job to the job list */,1.0,,/* addjob - Add a job to the job list */,
"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline)",0.0,"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid == 0) {,0.0,if (jobs[i].pid == 0) {,,
jobs[i].pid = pid;,0.0,jobs[i].pid = pid;,,
jobs[i].state = state;,0.0,jobs[i].state = state;,,
jobs[i].jid = nextjid++;,0.0,jobs[i].jid = nextjid++;,,
if (nextjid > MAXJOBS),0.0,if (nextjid > MAXJOBS),,
nextjid = 1;,0.0,nextjid = 1;,,
"strcpy(jobs[i].cmdline, cmdline);",0.0,"strcpy(jobs[i].cmdline, cmdline);",,
if(verbose){,0.0,if(verbose){,,
"printf(""Added job [%d] %d %s\n"", jobs[i].jid, jobs[i].pid, jobs[i].cmdline);",0.0,"printf(""Added job [%d] %d %s\n"", jobs[i].jid, jobs[i].pid, jobs[i].cmdline);",,
},0.0,},,
return 1;,0.0,return 1;,,
},0.0,},,
},0.0,},,
"printf(""Tried to create too many jobs\n"");",0.0,"printf(""Tried to create too many jobs\n"");",,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/* deletejob - Delete a job whose PID=pid from the job list */,1.0,,/* deletejob - Delete a job whose PID=pid from the job list */,
"int deletejob(struct job_t *jobs, pid_t pid)",0.0,"int deletejob(struct job_t *jobs, pid_t pid)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid == pid) {,0.0,if (jobs[i].pid == pid) {,,
clearjob(&jobs[i]);,0.0,clearjob(&jobs[i]);,,
nextjid = maxjid(jobs)+1;,0.0,nextjid = maxjid(jobs)+1;,,
return 1;,0.0,return 1;,,
},0.0,},,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
"/* fgpid - Return PID of current foreground job, 0 if no such job */",1.0,,"/* fgpid - Return PID of current foreground job, 0 if no such job */",
pid_t fgpid(struct job_t *jobs) {,0.0,pid_t fgpid(struct job_t *jobs) {,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].state == FG),0.0,if (jobs[i].state == FG),,
return jobs[i].pid;,0.0,return jobs[i].pid;,,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/* getjobpid  - Find a job (by PID) on the job list */,1.0,,/* getjobpid  - Find a job (by PID) on the job list */,
"struct job_t *getjobpid(struct job_t *jobs, pid_t pid) {",0.0,"struct job_t *getjobpid(struct job_t *jobs, pid_t pid) {",,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return NULL;,0.0,return NULL;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].pid == pid),0.0,if (jobs[i].pid == pid),,
return &jobs[i];,0.0,return &jobs[i];,,
return NULL;,0.0,return NULL;,,
},0.0,},,
,0.0,,,
/* getjobjid  - Find a job (by JID) on the job list */,1.0,,/* getjobjid  - Find a job (by JID) on the job list */,
"struct job_t *getjobjid(struct job_t *jobs, int jid)",0.0,"struct job_t *getjobjid(struct job_t *jobs, int jid)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (jid < 1),0.0,if (jid < 1),,
return NULL;,0.0,return NULL;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].jid == jid),0.0,if (jobs[i].jid == jid),,
return &jobs[i];,0.0,return &jobs[i];,,
return NULL;,0.0,return NULL;,,
},0.0,},,
,0.0,,,
/* pid2jid - Map process ID to job ID */,1.0,,/* pid2jid - Map process ID to job ID */,
int pid2jid(pid_t pid),0.0,int pid2jid(pid_t pid),,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].pid == pid) {,0.0,if (jobs[i].pid == pid) {,,
return jobs[i].jid;,0.0,return jobs[i].jid;,,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/* listjobs - Print the job list */,1.0,,/* listjobs - Print the job list */,
void listjobs(struct job_t *jobs),0.0,void listjobs(struct job_t *jobs),,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid != 0) {,0.0,if (jobs[i].pid != 0) {,,
"printf(""[%d] (%d) "", jobs[i].jid, jobs[i].pid);",0.0,"printf(""[%d] (%d) "", jobs[i].jid, jobs[i].pid);",,
switch (jobs[i].state) {,0.0,switch (jobs[i].state) {,,
case BG:,0.0,case BG:,,
"printf(""Running "");",0.0,"printf(""Running "");",,
break;,0.0,break;,,
case FG:,0.0,case FG:,,
"printf(""Foreground "");",0.0,"printf(""Foreground "");",,
break;,0.0,break;,,
case ST:,0.0,case ST:,,
"printf(""Stopped "");",0.0,"printf(""Stopped "");",,
break;,0.0,break;,,
default:,0.0,default:,,
"printf(""listjobs: Internal error: job[%d].state=%d "",",0.0,"printf(""listjobs: Internal error: job[%d].state=%d "",",,
"i, jobs[i].state);",0.0,"i, jobs[i].state);",,
},0.0,},,
"printf(""%s"", jobs[i].cmdline);",0.0,"printf(""%s"", jobs[i].cmdline);",,
},0.0,},,
},0.0,},,
},0.0,},,
/******************************,1.0,,/******************************,
* end job list helper routines,1.0,,* end job list helper routines,
******************************/,0.0,******************************/,,
,0.0,,,
,0.0,,,
/***********************,1.0,,/***********************,
* Other helper routines,1.0,,* Other helper routines,
***********************/,0.0,***********************/,,
,0.0,,,
/*,1.0,,/*,
* usage - print a help message,1.0,,* usage - print a help message,
*/,0.0,*/,,
void usage(void),0.0,void usage(void),,
{,0.0,{,,
"printf(""Usage: shell [-hvp]\n"");",0.0,"printf(""Usage: shell [-hvp]\n"");",,
"printf(""   -h   print this message\n"");",0.0,"printf(""   -h   print this message\n"");",,
"printf(""   -v   print additional diagnostic information\n"");",0.0,"printf(""   -v   print additional diagnostic information\n"");",,
"printf(""   -p   do not emit a command prompt\n"");",0.0,"printf(""   -p   do not emit a command prompt\n"");",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* unix_error - unix-style error routine,1.0,,* unix_error - unix-style error routine,
*/,0.0,*/,,
void unix_error(char *msg),0.0,void unix_error(char *msg),,
{,0.0,{,,
"fprintf(stdout, ""%s: %s\n"", msg, strerror(errno));",0.0,"fprintf(stdout, ""%s: %s\n"", msg, strerror(errno));",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* app_error - application-style error routine,1.0,,* app_error - application-style error routine,
*/,0.0,*/,,
void app_error(char *msg),0.0,void app_error(char *msg),,
{,0.0,{,,
"fprintf(stdout, ""%s\n"", msg);",0.0,"fprintf(stdout, ""%s\n"", msg);",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Signal - wrapper for the sigaction function,1.0,,* Signal - wrapper for the sigaction function,
*/,0.0,*/,,
"handler_t *Signal(int signum, handler_t *handler)",0.0,"handler_t *Signal(int signum, handler_t *handler)",,
{,0.0,{,,
"struct sigaction action, old_action;",0.0,"struct sigaction action, old_action;",,
,0.0,,,
action.sa_handler = handler;,0.0,action.sa_handler = handler;,,
sigemptyset(&action.sa_mask); /* block sigs of type being handled */,1.0,,sigemptyset(&action.sa_mask); /* block sigs of type being handled */,
action.sa_flags = SA_RESTART; /* restart syscalls if possible */,1.0,,action.sa_flags = SA_RESTART; /* restart syscalls if possible */,
,0.0,,,
"if (sigaction(signum, &action, &old_action) < 0)",0.0,"if (sigaction(signum, &action, &old_action) < 0)",,
"unix_error(""Signal error"");",0.0,"unix_error(""Signal error"");",,
return (old_action.sa_handler);,0.0,return (old_action.sa_handler);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigquit_handler - The driver program can gracefully terminate the,1.0,,* sigquit_handler - The driver program can gracefully terminate the,
*    child shell by sending it a SIGQUIT signal.,1.0,,*    child shell by sending it a SIGQUIT signal.,
*/,0.0,*/,,
void sigquit_handler(int sig),0.0,void sigquit_handler(int sig),,
{,0.0,{,,
"printf(""Terminating after receipt of SIGQUIT signal\n"");",0.0,"printf(""Terminating after receipt of SIGQUIT signal\n"");",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
,0.0,,,
,0.0,,,
/*,1.0,,/*,
* My helpers,1.0,,* My helpers,
*/,0.0,*/,,
,0.0,,,
pid_t Fork(void) {,0.0,pid_t Fork(void) {,,
pid_t pid;,0.0,pid_t pid;,,
,0.0,,,
if ((pid = fork()) < 0),0.0,if ((pid = fork()) < 0),,
"unix_error(""Fork error"");",0.0,"unix_error(""Fork error"");",,
return pid;,0.0,return pid;,,
},0.0,},,
,0.0,,,
"void Kill(pid_t pid, int signum)",0.0,"void Kill(pid_t pid, int signum)",,
{,0.0,{,,
int rc;,0.0,int rc;,,
,0.0,,,
"if ((rc = kill(pid, signum)) < 0)",0.0,"if ((rc = kill(pid, signum)) < 0)",,
"unix_error(""Kill error"");",0.0,"unix_error(""Kill error"");",,
},0.0,},,
,0.0,,,
"void Setpgid(pid_t pid, pid_t pgid) {",0.0,"void Setpgid(pid_t pid, pid_t pgid) {",,
int rc;,0.0,int rc;,,
,0.0,,,
"if ((rc = setpgid(pid, pgid)) < 0)",0.0,"if ((rc = setpgid(pid, pgid)) < 0)",,
"unix_error(""Setpgid error"");",0.0,"unix_error(""Setpgid error"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
"void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset) {",0.0,"void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset) {",,
"if (sigprocmask(how, set, oldset) < 0)",0.0,"if (sigprocmask(how, set, oldset) < 0)",,
"unix_error(""Sigprocmask error"");",0.0,"unix_error(""Sigprocmask error"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
void Sigemptyset(sigset_t *set) {,0.0,void Sigemptyset(sigset_t *set) {,,
if (sigemptyset(set) < 0),0.0,if (sigemptyset(set) < 0),,
"unix_error(""Sigemptyset error"");",0.0,"unix_error(""Sigemptyset error"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
void Sigfillset(sigset_t *set) {,0.0,void Sigfillset(sigset_t *set) {,,
if (sigfillset(set) < 0),0.0,if (sigfillset(set) < 0),,
"unix_error(""Sigfillset error"");",0.0,"unix_error(""Sigfillset error"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
"void Sigaddset(sigset_t *set, int signum) {",0.0,"void Sigaddset(sigset_t *set, int signum) {",,
"if (sigaddset(set, signum) < 0)",0.0,"if (sigaddset(set, signum) < 0)",,
"unix_error(""Sigaddset error"");",0.0,"unix_error(""Sigaddset error"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
,0.0,,,
"void sh_execve(const char *filename, char *const argv[], char *const envp[]) {",0.0,"void sh_execve(const char *filename, char *const argv[], char *const envp[]) {",,
"if (execve(filename, argv, envp) < 0) {",0.0,"if (execve(filename, argv, envp) < 0) {",,
"/* fprintf(stdout, ""%s: %s\n"", filename, strerror(errno)); */",1.0,,"/* fprintf(stdout, ""%s: %s\n"", filename, strerror(errno)); */",
// don鈥檛 believe what your instructor says,0.5,,// don鈥檛 believe what your instructor says,
"fprintf(stdout, ""%s: Command not found\n"", filename);",0.0,"fprintf(stdout, ""%s: Command not found\n"", filename);",,
exit(1);,0.0,exit(1);,,
},0.0,},,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Return a mask for SIGCHLD,1.0,,* Return a mask for SIGCHLD,
*/,0.0,*/,,
sigset_t sigchld_mask () {,0.0,sigset_t sigchld_mask () {,,
sigset_t mask;,0.0,sigset_t mask;,,
Sigemptyset(&mask);,0.0,Sigemptyset(&mask);,,
"Sigaddset(&mask, SIGCHLD);",0.0,"Sigaddset(&mask, SIGCHLD);",,
return mask;,0.0,return mask;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Put job to foreground and block,1.0,,* Put job to foreground and block,
*/,0.0,*/,,
void put_fg(struct job_t *job) {,0.0,void put_fg(struct job_t *job) {,,
// protect job list from sigchld_handler,0.5,,// protect job list from sigchld_handler,
sigset_t mask = sigchld_mask();,0.0,sigset_t mask = sigchld_mask();,,
"Sigprocmask(SIG_BLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_BLOCK, &mask, NULL);",,
,0.0,,,
if (job->state == ST),0.0,if (job->state == ST),,
// bg and stopped,0.5,,// bg and stopped,
// send to process group,0.5,,// send to process group,
"Kill(-(job->pid), SIGCONT);",0.0,"Kill(-(job->pid), SIGCONT);",,
// send nothing if bg and running,0.5,,// send nothing if bg and running,
job->state = FG;,0.0,job->state = FG;,,
,0.0,,,
"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",0.0,"Sigprocmask(SIG_UNBLOCK, &mask, NULL);",,
,0.0,,,
waitfg(job->pid);,0.0,waitfg(job->pid);,,
return;,0.0,return;,,
},0.0,},,
/*,1.0,,/*,
* Continue the job in the background,1.0,,* Continue the job in the background,
*/,0.0,*/,,
void bg_cont(struct job_t *job) {,0.0,void bg_cont(struct job_t *job) {,,
if (job->state == ST),0.0,if (job->state == ST),,
// bg stopped,0.5,,// bg stopped,
"Kill(-(job->pid), SIGCONT);",0.0,"Kill(-(job->pid), SIGCONT);",,
job->state = BG;,0.0,job->state = BG;,,
print_bg_job(job);,0.0,print_bg_job(job);,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
void print_bg_job(struct job_t *job) {,0.0,void print_bg_job(struct job_t *job) {,,
// don鈥檛 print extra newline,0.5,,// don鈥檛 print extra newline,
"printf(""[%d] (%d) %s"", job->jid, job->pid, job->cmdline);",0.0,"printf(""[%d] (%d) %s"", job->jid, job->pid, job->cmdline);",,
},0.0,},,
