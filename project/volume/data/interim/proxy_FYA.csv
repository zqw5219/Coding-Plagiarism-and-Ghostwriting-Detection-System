originalCode,typeIndicator,pureCode,pureComment,pureMacro
#include <stdio.h>,0.0,#include <stdio.h>,,
"#include ""csapp.h""",0.0,"#include ""csapp.h""",,
"#include ""cache.h""",0.0,"#include ""cache.h""",,
"#include ""string.h""",0.0,"#include ""string.h""",,
,0.0,,,
/* You won't lose style points for including this long line in your code */,1.0,,/* You won't lose style points for including this long line in your code */,
"static const char *user_agent_hdr = ""User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n"";",0.0,"static const char *user_agent_hdr = ""User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n"";",,
,0.0,,,
"int parse_url(const char *url, char *host, char *port, char *path);",0.0,"int parse_url(const char *url, char *host, char *port, char *path);",,
"int read_header(char *buf, rio_t *riop, char *host);",0.0,"int read_header(char *buf, rio_t *riop, char *host);",,
void serve (int connfd);,0.0,void serve (int connfd);,,
"size_t request_page(char *host, char *port, char *header,",0.0,"size_t request_page(char *host, char *port, char *header,",,
"char **resp_bufp, char *uri);",0.0,"char **resp_bufp, char *uri);",,
"int  read_response_header(rio_t *riop, char* header_buf,",0.0,"int  read_response_header(rio_t *riop, char* header_buf,",,
"size_t *content_len, int *ok,",0.0,"size_t *content_len, int *ok,",,
int *has_content_len);,0.0,int *has_content_len);,,
"size_t read_to_eof(rio_t *riop, char **bufp);",0.0,"size_t read_to_eof(rio_t *riop, char **bufp);",,
"size_t read_bytes(rio_t *riop, char* bufp, size_t count);",0.0,"size_t read_bytes(rio_t *riop, char* bufp, size_t count);",,
"char *merge_resp(char *p1, size_t len1, char *p2, size_t len2);",0.0,"char *merge_resp(char *p1, size_t len1, char *p2, size_t len2);",,
,0.0,,,
CacheList *cache;,0.0,CacheList *cache;,,
,0.0,,,
/*,1.0,,/*,
* init cache,1.0,,* init cache,
*,1.0,,*,
* Ignore SIGPIPE,1.0,,* Ignore SIGPIPE,
*,1.0,,*,
* Start listening on given port,1.0,,* Start listening on given port,
*,1.0,,*,
* loop:,1.0,,* loop:,
*  accept client connection,1.0,,*  accept client connection,
*  get relevant info,1.0,,*  get relevant info,
*  serve content with serve(),1.0,,*  serve content with serve(),
*  close socket,1.0,,*  close socket,
*/,0.0,*/,,
"int main(int argc, char** argv)",0.0,"int main(int argc, char** argv)",,
{,0.0,{,,
if (argc != 2) {,0.0,if (argc != 2) {,,
"printf(""Wrong number of arguments: %d, requires 1\n"", argc);",0.0,"printf(""Wrong number of arguments: %d, requires 1\n"", argc);",,
return -1;,0.0,return -1;,,
},0.0,},,
,0.0,,,
cache = malloc(sizeof(CacheList));,0.0,cache = malloc(sizeof(CacheList));,,
cache_init(cache);,0.0,cache_init(cache);,,
,0.0,,,
"int listenfd, connfd;",0.0,"int listenfd, connfd;",,
socklen_t clientlen;,0.0,socklen_t clientlen;,,
struct sockaddr_storage clientaddr;,0.0,struct sockaddr_storage clientaddr;,,
"char client_hostname[MAXLINE], client_port[MAXLINE];",0.0,"char client_hostname[MAXLINE], client_port[MAXLINE];",,
,0.0,,,
"Signal(SIGPIPE, SIG_IGN);",0.0,"Signal(SIGPIPE, SIG_IGN);",,
if ((listenfd = open_listenfd(argv[1])) < 0) {,0.0,if ((listenfd = open_listenfd(argv[1])) < 0) {,,
"printf(""Can't find a listen port\n"");",0.0,"printf(""Can't find a listen port\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
,0.0,,,
while (1) {,0.0,while (1) {,,
// accept,0.5,,// accept,
clientlen = sizeof(struct sockaddr_storage);,0.0,clientlen = sizeof(struct sockaddr_storage);,,
"connfd = accept(listenfd, (SA *)&clientaddr, &clientlen);",0.0,"connfd = accept(listenfd, (SA *)&clientaddr, &clientlen);",,
if (connfd < 0) {,0.0,if (connfd < 0) {,,
"printf(""accept error\n"");",0.0,"printf(""accept error\n"");",,
continue;,0.0,continue;,,
},0.0,},,
// get info,0.5,,// get info,
"int ret = getnameinfo((SA *) &clientaddr, clientlen, client_hostname, MAXLINE,",0.0,"int ret = getnameinfo((SA *) &clientaddr, clientlen, client_hostname, MAXLINE,",,
"client_port, MAXLINE, 0);",0.0,"client_port, MAXLINE, 0);",,
if (ret != 0) {,0.0,if (ret != 0) {,,
"printf(""getnameinfo error: %s\n"", gai_strerror(ret));",0.0,"printf(""getnameinfo error: %s\n"", gai_strerror(ret));",,
continue;,0.0,continue;,,
},0.0,},,
"printf(""Connected to %s:%s\n"", client_hostname, client_port);",0.0,"printf(""Connected to %s:%s\n"", client_hostname, client_port);",,
// serve content,0.5,,// serve content,
serve(connfd);,0.0,serve(connfd);,,
close(connfd);,0.0,close(connfd);,,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Serve content to client CLIENT_FD.,1.0,,* Serve content to client CLIENT_FD.,
*,1.0,,*,
* read first line from client,1.0,,* read first line from client,
*,1.0,,*,
"* parse it to get host, port, path",1.0,,"* parse it to get host, port, path",
*,1.0,,*,
"* read rest of the headers, add default headers,",1.0,,"* read rest of the headers, add default headers,",
* and request remote page from host with our header.,1.0,,* and request remote page from host with our header.,
*,1.0,,*,
* send the response from remote server to our client,1.0,,* send the response from remote server to our client,
*/,0.0,*/,,
void serve (int client_fd) {,0.0,void serve (int client_fd) {,,
rio_t rio;,0.0,rio_t rio;,,
"rio_readinitb(&rio, client_fd);",0.0,"rio_readinitb(&rio, client_fd);",,
,0.0,,,
// read first line,0.5,,// read first line,
char line[MAXLINE];,0.0,char line[MAXLINE];,,
"if ((rio_readlineb(&rio, &line, MAXLINE)) < 0) {",0.0,"if ((rio_readlineb(&rio, &line, MAXLINE)) < 0) {",,
"printf(""Failed to read header\n"");",0.0,"printf(""Failed to read header\n"");",,
return;,0.0,return;,,
},0.0,},,
"printf(""Received request: %s"", line);",0.0,"printf(""Received request: %s"", line);",,
,0.0,,,
// parse first line,0.5,,// parse first line,
char method[MAXLINE];,0.0,char method[MAXLINE];,,
char uri[MAXLINE];,0.0,char uri[MAXLINE];,,
char version[MAXLINE];,0.0,char version[MAXLINE];,,
"if (sscanf(line, ""%s %s %s\r\n"", method, uri, version) != 3) {",0.0,"if (sscanf(line, ""%s %s %s\r\n"", method, uri, version) != 3) {",,
"printf(""Failed to parse header: %s\n"", line);",0.0,"printf(""Failed to parse header: %s\n"", line);",,
return;,0.0,return;,,
},0.0,},,
"if (strcasecmp(method, ""GET"") != 0) {",0.0,"if (strcasecmp(method, ""GET"") != 0) {",,
"printf(""not GET, skip\n"");",0.0,"printf(""not GET, skip\n"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
// parse uri,0.5,,// parse uri,
char host[MAXLINE];,0.0,char host[MAXLINE];,,
char port[MAXLINE];,0.0,char port[MAXLINE];,,
char path[MAXLINE];,0.0,char path[MAXLINE];,,
"parse_url(uri, host, port, path);",0.0,"parse_url(uri, host, port, path);",,
"if (strcmp(host, """") == 0) {",0.0,"if (strcmp(host, """") == 0) {",,
"printf(""Failed to parse uri: %s"", uri);",0.0,"printf(""Failed to parse uri: %s"", uri);",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
// read headers and process them,0.5,,// read headers and process them,
char header[MAXBUF];,0.0,char header[MAXBUF];,,
"sprintf(header, ""GET %s HTTP/1.0\r\n"", path);",0.0,"sprintf(header, ""GET %s HTTP/1.0\r\n"", path);",,
"if (read_header(header, &rio, host) < 0) {",0.0,"if (read_header(header, &rio, host) < 0) {",,
"printf(""read_header failed, header:\n"");",0.0,"printf(""read_header failed, header:\n"");",,
"printf(""%s"", header);",0.0,"printf(""%s"", header);",,
return;,0.0,return;,,
} else {,0.0,} else {,,
"printf(""read_header success, header:\n"");",0.0,"printf(""read_header success, header:\n"");",,
"printf(""%s"", header);",0.0,"printf(""%s"", header);",,
},0.0,},,
,0.0,,,
// request for page,0.5,,// request for page,
char *resp_buf;,0.0,char *resp_buf;,,
int resp_len;,0.0,int resp_len;,,
"if ((resp_len = request_page(host, port, header,",0.0,"if ((resp_len = request_page(host, port, header,",,
"&resp_buf, uri)) < 0) {",0.0,"&resp_buf, uri)) < 0) {",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
"printf(""Got page from remote server (or cache):\n"");",0.0,"printf(""Got page from remote server (or cache):\n"");",,
"// printf(""%.*s"", resp_len, resp_buf);",0.5,,"// printf(""%.*s"", resp_len, resp_buf);",
,0.0,,,
// send to client,0.5,,// send to client,
"if (rio_writen(client_fd, resp_buf, resp_len) < 0) {",0.0,"if (rio_writen(client_fd, resp_buf, resp_len) < 0) {",,
free(resp_buf);,0.0,free(resp_buf);,,
"printf(""Write to client failed\n"");",0.0,"printf(""Write to client failed\n"");",,
return;,0.0,return;,,
} else {,0.0,} else {,,
free(resp_buf);,0.0,free(resp_buf);,,
"printf(""Sent to client\n"");",0.0,"printf(""Sent to client\n"");",,
},0.0,},,
,0.0,,,
"printf(""Served one page\n"");",0.0,"printf(""Served one page\n"");",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
"* Parse URL into HOST, PORT and PATH",1.0,,"* Parse URL into HOST, PORT and PATH",
*/,0.0,*/,,
"int parse_url(const char *url, char *host, char *port, char *path) {",0.0,"int parse_url(const char *url, char *host, char *port, char *path) {",,
"// 1 if https, 0 if https",0.5,,"// 1 if https, 0 if https",
int http = 0;,0.0,int http = 0;,,
// beginning index of host,0.5,,// beginning index of host,
,0.0,,,
int host_beg;,0.0,int host_beg;,,
// length of host,0.5,,// length of host,
int host_count = 0;,0.0,int host_count = 0;,,
"// 1 if port exists, 0 if not",0.5,,"// 1 if port exists, 0 if not",
,0.0,,,
int port_exist = 0;,0.0,int port_exist = 0;,,
// beginning index of port,0.5,,// beginning index of port,
int port_beg = 0;,0.0,int port_beg = 0;,,
// length of port,0.5,,// length of port,
int port_count = 0;,0.0,int port_count = 0;,,
"// 1 if path exists, 0 if not",0.5,,"// 1 if path exists, 0 if not",
,0.0,,,
int path_exist = 0;,0.0,int path_exist = 0;,,
// beginning index of path,0.5,,// beginning index of path,
int path_beg = 0;,0.0,int path_beg = 0;,,
// length of path,0.5,,// length of path,
int path_count = 0;,0.0,int path_count = 0;,,
,0.0,,,
// counter,0.5,,// counter,
int i = 0;,0.0,int i = 0;,,
// state for finite machine,0.5,,// state for finite machine,
int state = 0;,0.0,int state = 0;,,
,0.0,,,
// check http v. https,0.5,,// check http v. https,
"if (strncasecmp(url, ""http://"", 7) == 0) {",0.5,"if (strncasecmp(url, ""http:","//"", 7) == 0) {",
http = 1;,0.0,http = 1;,,
i = 7;,0.0,i = 7;,,
},0.0,},,
"if (strncasecmp(url, ""https://"", 8) == 0) {",0.5,"if (strncasecmp(url, ""https:","//"", 8) == 0) {",
i = 8;,0.0,i = 8;,,
},0.0,},,
,0.0,,,
// find each part,0.5,,// find each part,
host_beg = i;,0.0,host_beg = i;,,
while (url[i] != '\0') {,0.0,while (url[i] != '\0') {,,
switch (state) {,0.0,switch (state) {,,
// we are in host section,0.5,,// we are in host section,
case 0:,0.0,case 0:,,
if (url[i] == ':') {,0.0,if (url[i] == ':') {,,
state = 1;,0.0,state = 1;,,
port_exist = 1;,0.0,port_exist = 1;,,
port_beg = i+1;,0.0,port_beg = i+1;,,
} else if (url[i] == '/') {,0.0,} else if (url[i] == '/') {,,
state = 2;,0.0,state = 2;,,
path_exist = 1;,0.0,path_exist = 1;,,
path_count = 1;,0.0,path_count = 1;,,
path_beg = i;,0.0,path_beg = i;,,
} else,0.0,} else,,
host_count++;,0.0,host_count++;,,
break;,0.0,break;,,
// we are in port section,0.5,,// we are in port section,
case 1:,0.0,case 1:,,
if (url[i] == '/') {,0.0,if (url[i] == '/') {,,
state = 2;,0.0,state = 2;,,
path_exist = 1;,0.0,path_exist = 1;,,
path_count = 1;,0.0,path_count = 1;,,
path_beg = i;,0.0,path_beg = i;,,
} else,0.0,} else,,
port_count++;,0.0,port_count++;,,
break;,0.0,break;,,
// we are in path section,0.5,,// we are in path section,
case 2:,0.0,case 2:,,
path_count++;,0.0,path_count++;,,
},0.0,},,
i++;,0.0,i++;,,
},0.0,},,
,0.0,,,
// copy each part,0.5,,// copy each part,
"strncpy(host, url+host_beg, host_count);",0.0,"strncpy(host, url+host_beg, host_count);",,
host[host_count] = '\0';,0.0,host[host_count] = '\0';,,
,0.0,,,
if (port_exist) {,0.0,if (port_exist) {,,
"strncpy(port, url+port_beg, port_count);",0.0,"strncpy(port, url+port_beg, port_count);",,
port[port_count] = '\0';,0.0,port[port_count] = '\0';,,
} else {,0.0,} else {,,
port[0] = '8';,0.0,port[0] = '8';,,
port[1] = '0';,0.0,port[1] = '0';,,
port[2] = '\0';,0.0,port[2] = '\0';,,
},0.0,},,
,0.0,,,
if (path_exist) {,0.0,if (path_exist) {,,
"strncpy(path, url+path_beg, path_count);",0.0,"strncpy(path, url+path_beg, path_count);",,
path[path_count] = '\0';,0.0,path[path_count] = '\0';,,
} else {,0.0,} else {,,
path[0] = '/';,0.0,path[0] = '/';,,
path[1] = '\0';,0.0,path[1] = '\0';,,
},0.0,},,
,0.0,,,
return http;,0.0,return http;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Read the rest headers from RIOP and create a proper request header,1.0,,* Read the rest headers from RIOP and create a proper request header,
* to HOST and put into BUF.,1.0,,* to HOST and put into BUF.,
*,1.0,,*,
"* Get each line and parse, look for Connection, etc",1.0,,"* Get each line and parse, look for Connection, etc",
"* If key is one of Connection, etc, don鈥檛 add to BUF",1.0,,"* If key is one of Connection, etc, don鈥檛 add to BUF",
"* if not, add to BUF",1.0,,"* if not, add to BUF",
* Finally add our preset headers to BUF,1.0,,* Finally add our preset headers to BUF,
*/,0.0,*/,,
"int read_header(char *buf, rio_t *riop, char *host) {",0.0,"int read_header(char *buf, rio_t *riop, char *host) {",,
int host_exists = 0;,0.0,int host_exists = 0;,,
,0.0,,,
while (1) {,0.0,while (1) {,,
char line[MAXLINE];,0.0,char line[MAXLINE];,,
char key[MAXLINE];,0.0,char key[MAXLINE];,,
char value[MAXLINE];,0.0,char value[MAXLINE];,,
size_t count;,0.0,size_t count;,,
// parse each line,0.5,,// parse each line,
"if ((count = (rio_readlineb(riop, line, MAXLINE))) < 0)",0.0,"if ((count = (rio_readlineb(riop, line, MAXLINE))) < 0)",,
return -1;,0.0,return -1;,,
"if (strcmp(""\r\n"", line) == 0)",0.0,"if (strcmp(""\r\n"", line) == 0)",,
break;,0.0,break;,,
if (count == 0) {,0.0,if (count == 0) {,,
"printf(""Reached EOF without seeing \\r\\n\n"");",0.0,"printf(""Reached EOF without seeing \\r\\n\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
"if (sscanf(line, ""%[^:]: %s\r\n"", key, value) != 2) {",0.0,"if (sscanf(line, ""%[^:]: %s\r\n"", key, value) != 2) {",,
"printf(""Failed to parse header: %s"", line);",0.0,"printf(""Failed to parse header: %s"", line);",,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
"printf(""Parsed header: %s: %s\n"", key, value);",0.0,"printf(""Parsed header: %s: %s\n"", key, value);",,
,0.0,,,
// handle header by their key,0.5,,// handle header by their key,
"if (strcasecmp(key, ""Host"") == 0) {",0.0,"if (strcasecmp(key, ""Host"") == 0) {",,
host_exists = 1;,0.0,host_exists = 1;,,
"if (sprintf(buf, ""%s%s"", buf, line) < 0)",0.0,"if (sprintf(buf, ""%s%s"", buf, line) < 0)",,
return -1;,0.0,return -1;,,
"} else if ((strcasecmp(key, ""Connection"") &&",0.0,"} else if ((strcasecmp(key, ""Connection"") &&",,
"strcasecmp(key, ""Proxy-Connection"") &&",0.0,"strcasecmp(key, ""Proxy-Connection"") &&",,
"strcasecmp(key, ""User-Agent"") &&",0.0,"strcasecmp(key, ""User-Agent"") &&",,
"strcasecmp(key, ""If-Modified-Since"") &&",0.0,"strcasecmp(key, ""If-Modified-Since"") &&",,
"strcasecmp(key, ""If-None-Match"")) == 0)",0.0,"strcasecmp(key, ""If-None-Match"")) == 0)",,
// zero if any one is zero,0.5,,// zero if any one is zero,
// don鈥檛 add them to our new header,0.5,,// don鈥檛 add them to our new header,
continue;,0.0,continue;,,
else,0.0,else,,
"if (sprintf(buf, ""%s%s"", buf, line) < 0)",0.0,"if (sprintf(buf, ""%s%s"", buf, line) < 0)",,
return -1;,0.0,return -1;,,
},0.0,},,
// add preset headers,0.5,,// add preset headers,
if (!host_exists),0.0,if (!host_exists),,
"if (sprintf(buf, ""%sHost: %s\r\n"", buf, host) < 0)",0.0,"if (sprintf(buf, ""%sHost: %s\r\n"", buf, host) < 0)",,
return -1;,0.0,return -1;,,
"if (sprintf(buf, ""%sConnection: close\r\n"", buf) < 0)",0.0,"if (sprintf(buf, ""%sConnection: close\r\n"", buf) < 0)",,
return -1;,0.0,return -1;,,
"if (sprintf(buf, ""%sProxy-Connection: close\r\n"", buf) < 0)",0.0,"if (sprintf(buf, ""%sProxy-Connection: close\r\n"", buf) < 0)",,
return -1;,0.0,return -1;,,
"if (sprintf(buf, ""%s%s\r\n"", buf, user_agent_hdr) < 0)",0.0,"if (sprintf(buf, ""%s%s\r\n"", buf, user_agent_hdr) < 0)",,
return -1;,0.0,return -1;,,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
"* Request page from HOST:PORT with HEADER, put response into",1.0,,"* Request page from HOST:PORT with HEADER, put response into",
"* a buffer and put a pointer into RESP_BUFP, URI is for caching.",1.0,,"* a buffer and put a pointer into RESP_BUFP, URI is for caching.",
*,1.0,,*,
"* First check if URI is in cache, if so, copy the header and content",1.0,,"* First check if URI is in cache, if so, copy the header and content",
* out and combine them into one buffer and return it.,1.0,,* out and combine them into one buffer and return it.,
*,1.0,,*,
"* If not in cache, open a client socket and connect to remote server,",1.0,,"* If not in cache, open a client socket and connect to remote server,",
"* write HEADER, and get back response headers into RESP_HEADER.",1.0,,"* write HEADER, and get back response headers into RESP_HEADER.",
*,1.0,,*,
"* Now we read contents, if response header has Content-Length,",1.0,,"* Now we read contents, if response header has Content-Length,",
"* read exact that much, else read until EOF.",1.0,,"* read exact that much, else read until EOF.",
*,1.0,,*,
* Cache the header and content if all 3 criterions are satisfied.,1.0,,* Cache the header and content if all 3 criterions are satisfied.,
*,1.0,,*,
* Finally combine them into one buffer and return it.,1.0,,* Finally combine them into one buffer and return it.,
*/,0.0,*/,,
"size_t request_page(char *host, char *port, char *header,",0.0,"size_t request_page(char *host, char *port, char *header,",,
"char **resp_bufp, char *uri) {",0.0,"char **resp_bufp, char *uri) {",,
// first try to get from cache,0.5,,// first try to get from cache,
"CachedItem *item = find(uri, cache);",0.0,"CachedItem *item = find(uri, cache);",,
if (item != NULL) {,0.0,if (item != NULL) {,,
"printf(""Found in cache\n"");",0.0,"printf(""Found in cache\n"");",,
size_t header_len = strlen(item->headers);,0.0,size_t header_len = strlen(item->headers);,,
"printf(""header: %lu bytes, content: %lu bytes\n"",",0.0,"printf(""header: %lu bytes, content: %lu bytes\n"",",,
"header_len, item->size);",0.0,"header_len, item->size);",,
// make copies of cache,0.5,,// make copies of cache,
char *header = strdup(item->headers);,0.0,char *header = strdup(item->headers);,,
char *content = malloc(item->size);,0.0,char *content = malloc(item->size);,,
if (header == NULL || content == NULL) {,0.0,if (header == NULL || content == NULL) {,,
"printf(""Make copies from cache failed\n"");",0.0,"printf(""Make copies from cache failed\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
"memcpy(content, item->item_p, item->size);",0.0,"memcpy(content, item->item_p, item->size);",,
// merge data and return it,0.5,,// merge data and return it,
"char *ret_buf = merge_resp(header, header_len,",0.0,"char *ret_buf = merge_resp(header, header_len,",,
"content, item->size);",0.0,"content, item->size);",,
free(header);,0.0,free(header);,,
free(content);,0.0,free(content);,,
if (ret_buf == NULL) {,0.0,if (ret_buf == NULL) {,,
"printf(""merge_resp failed\n"");",0.0,"printf(""merge_resp failed\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
*resp_bufp = ret_buf;,0.0,*resp_bufp = ret_buf;,,
return item->size + header_len;,0.0,return item->size + header_len;,,
},0.0,},,
,0.0,,,
"// if no cache, request from remote server",0.5,,"// if no cache, request from remote server",
int client_fd;,0.0,int client_fd;,,
,0.0,,,
// connect to server,0.5,,// connect to server,
"if ((client_fd = open_clientfd(host, port)) < 0) {",0.0,"if ((client_fd = open_clientfd(host, port)) < 0) {",,
"printf(""Open client port failed\n"");",0.0,"printf(""Open client port failed\n"");",,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
"printf(""Client port opened: %s\n"", port);",0.0,"printf(""Client port opened: %s\n"", port);",,
,0.0,,,
,0.0,,,
// write,0.5,,// write,
"if (rio_writen(client_fd, header, strlen(header)) < 0) {",0.0,"if (rio_writen(client_fd, header, strlen(header)) < 0) {",,
"printf(""Failed to write to remote server\n"");",0.0,"printf(""Failed to write to remote server\n"");",,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
"printf(""Wrote to remote server\n"");",0.0,"printf(""Wrote to remote server\n"");",,
,0.0,,,
// read header,0.5,,// read header,
rio_t rio;,0.0,rio_t rio;,,
"rio_readinitb(&rio, client_fd);",0.0,"rio_readinitb(&rio, client_fd);",,
char resp_header[MAXBUF];,0.0,char resp_header[MAXBUF];,,
// length of http content,0.5,,// length of http content,
size_t content_len;,0.0,size_t content_len;,,
// length of header,0.5,,// length of header,
size_t resp_header_len;,0.0,size_t resp_header_len;,,
size_t count;,0.0,size_t count;,,
// 1 if status code is 200,0.5,,// 1 if status code is 200,
int ok;,0.0,int ok;,,
// 1 if header includes content-length,0.5,,// 1 if header includes content-length,
int has_content_len;,0.0,int has_content_len;,,
"if ((read_response_header(&rio, resp_header,",0.0,"if ((read_response_header(&rio, resp_header,",,
"&content_len, &ok,",0.0,"&content_len, &ok,",,
&has_content_len)) < 0) {,0.0,&has_content_len)) < 0) {,,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
},0.0,},,
resp_header_len = strlen(resp_header);,0.0,resp_header_len = strlen(resp_header);,,
,0.0,,,
// read content,0.5,,// read content,
// buffer for http content,0.5,,// buffer for http content,
char *resp_content;,0.0,char *resp_content;,,
// actually bytes read when content-length is given,0.5,,// actually bytes read when content-length is given,
size_t read_count = 0;,0.0,size_t read_count = 0;,,
// read until EOF,0.5,,// read until EOF,
if (!has_content_len) {,0.0,if (!has_content_len) {,,
"printf(""Reading until EOF\n"");",0.0,"printf(""Reading until EOF\n"");",,
"if ((count = read_to_eof(&rio, &resp_content)) < 0) {",0.0,"if ((count = read_to_eof(&rio, &resp_content)) < 0) {",,
"printf(""Read content failed\n"");",0.0,"printf(""Read content failed\n"");",,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
},0.0,},,
content_len = count;,0.0,content_len = count;,,
},0.0,},,
// read content_len,0.5,,// read content_len,
else {,0.0,else {,,
"printf(""Reading %d bytes from remote server\n"", (int) content_len);",0.0,"printf(""Reading %d bytes from remote server\n"", (int) content_len);",,
resp_content = malloc(content_len+1);,0.0,resp_content = malloc(content_len+1);,,
if (resp_content == NULL) {,0.0,if (resp_content == NULL) {,,
"printf(""malloc failed\n"");",0.0,"printf(""malloc failed\n"");",,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
},0.0,},,
"if ((read_count = read_bytes(&rio, resp_content, content_len)) < 0) {",0.0,"if ((read_count = read_bytes(&rio, resp_content, content_len)) < 0) {",,
"printf(""read from remote server failed\n"");",0.0,"printf(""read from remote server failed\n"");",,
free(resp_content);,0.0,free(resp_content);,,
},0.0,},,
},0.0,},,
"printf(""resp_buf: %lu bytes, resp_header: %lu bytes\n"",",0.0,"printf(""resp_buf: %lu bytes, resp_header: %lu bytes\n"",",,
"content_len, resp_header_len);",0.0,"content_len, resp_header_len);",,
,0.0,,,
// maybe cache the stuff,0.5,,// maybe cache the stuff,
"printf(""ok: %d\n"", ok);",0.0,"printf(""ok: %d\n"", ok);",,
"printf(""read_count: %lu\n"", read_count);",0.0,"printf(""read_count: %lu\n"", read_count);",,
"printf(""has_content_len: %d\n"", has_content_len);",0.0,"printf(""has_content_len: %d\n"", has_content_len);",,
if (ok && has_content_len && read_count == content_len) {,0.0,if (ok && has_content_len && read_count == content_len) {,,
"printf(""Save to cache\n"");",0.0,"printf(""Save to cache\n"");",,
// make copies of data for cache,0.5,,// make copies of data for cache,
char *contentcpy = malloc(content_len);,0.0,char *contentcpy = malloc(content_len);,,
char *headercpy = strdup(resp_header);,0.0,char *headercpy = strdup(resp_header);,,
char *uricpy = strdup(uri);,0.0,char *uricpy = strdup(uri);,,
if (contentcpy == NULL || headercpy == NULL,0.0,if (contentcpy == NULL || headercpy == NULL,,
|| uricpy == NULL) {,0.0,|| uricpy == NULL) {,,
"printf(""Make copy for cache failed\n"");",0.0,"printf(""Make copy for cache failed\n"");",,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
},0.0,},,
"memcpy(contentcpy, resp_content, content_len);",0.0,"memcpy(contentcpy, resp_content, content_len);",,
// save to cache,0.5,,// save to cache,
"cache_URL(uricpy, headercpy, contentcpy, content_len, cache);",0.0,"cache_URL(uricpy, headercpy, contentcpy, content_len, cache);",,
},0.0,},,
,0.0,,,
// we have content in resp_buf and header in resp_header,0.5,,// we have content in resp_buf and header in resp_header,
// stick them together,0.5,,// stick them together,
"char *ret_buf = merge_resp(resp_header, resp_header_len,",0.0,"char *ret_buf = merge_resp(resp_header, resp_header_len,",,
"resp_content, content_len);",0.0,"resp_content, content_len);",,
if (ret_buf == NULL) {,0.0,if (ret_buf == NULL) {,,
"printf(""Merge_resp failed\n"");",0.0,"printf(""Merge_resp failed\n"");",,
close(client_fd);,0.0,close(client_fd);,,
return -1;,0.0,return -1;,,
} else {,0.0,} else {,,
free(resp_content);,0.0,free(resp_content);,,
*resp_bufp = ret_buf;,0.0,*resp_bufp = ret_buf;,,
},0.0,},,
,0.0,,,
// close,0.5,,// close,
if (close(client_fd) < 0) {,0.0,if (close(client_fd) < 0) {,,
"printf(""close failed\n"");",0.0,"printf(""close failed\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
,0.0,,,
return content_len + resp_header_len;,0.0,return content_len + resp_header_len;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
"* Read response header from RIOP, and put header into HEADER_BUF, and",1.0,,"* Read response header from RIOP, and put header into HEADER_BUF, and",
* update various informations: set HAS_CONTENT_LENGTH to 1 and,1.0,,* update various informations: set HAS_CONTENT_LENGTH to 1 and,
* CONTENT_LENGTH to the length if found the key in the header; set OK to,1.0,,* CONTENT_LENGTH to the length if found the key in the header; set OK to,
* 1 if the ststus code is 200.,1.0,,* 1 if the ststus code is 200.,
*,1.0,,*,
* First read the frist line and parse it and update OK.,1.0,,* First read the frist line and parse it and update OK.,
* Add this line to HEADER_BUF.,1.0,,* Add this line to HEADER_BUF.,
*,1.0,,*,
* Then read each line and add to HEADER_BUF. If Content-Length,1.0,,* Then read each line and add to HEADER_BUF. If Content-Length,
"* is found, set CONTENT_LEN and set HAS_CONTENT_LEN to 1.",1.0,,"* is found, set CONTENT_LEN and set HAS_CONTENT_LEN to 1.",
*/,0.0,*/,,
"int read_response_header(rio_t *riop, char* header_buf, size_t *content_len,",0.0,"int read_response_header(rio_t *riop, char* header_buf, size_t *content_len,",,
"int *ok, int *has_content_len) {",0.0,"int *ok, int *has_content_len) {",,
// read first line,0.5,,// read first line,
char line[MAXLINE];,0.0,char line[MAXLINE];,,
,0.0,,,
"if (rio_readlineb(riop, line, MAXLINE) < 0) {",0.0,"if (rio_readlineb(riop, line, MAXLINE) < 0) {",,
"printf(""Failed to read header from remote server\n"");",0.0,"printf(""Failed to read header from remote server\n"");",,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
"printf(""Received response: %s"", line);",0.0,"printf(""Received response: %s"", line);",,
"sprintf(header_buf, ""%s"", line);",0.0,"sprintf(header_buf, ""%s"", line);",,
,0.0,,,
// parse first line,0.5,,// parse first line,
int status_code;,0.0,int status_code;,,
char version[MAXLINE];,0.0,char version[MAXLINE];,,
char status_msg[MAXLINE];,0.0,char status_msg[MAXLINE];,,
"if (sscanf(line, ""%s %d %s\r\n"", version, &status_code, status_msg) < 0) {",0.0,"if (sscanf(line, ""%s %d %s\r\n"", version, &status_code, status_msg) < 0) {",,
"printf(""Parse first line failed\n"");",0.0,"printf(""Parse first line failed\n"");",,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
"printf(""Parse success: %s %d %s\n"", version, status_code, status_msg);",0.0,"printf(""Parse success: %s %d %s\n"", version, status_code, status_msg);",,
if (status_code == 200),0.0,if (status_code == 200),,
*ok = 1;,0.0,*ok = 1;,,
else,0.0,else,,
*ok = 0;,0.0,*ok = 0;,,
,0.0,,,
*content_len = 0;,0.0,*content_len = 0;,,
*has_content_len = 0;,0.0,*has_content_len = 0;,,
size_t count;,0.0,size_t count;,,
// read rest line,0.5,,// read rest line,
while (1) {,0.0,while (1) {,,
// read a line,0.5,,// read a line,
"if ((count = rio_readlineb(riop, line, MAXLINE)) < 0) {",0.0,"if ((count = rio_readlineb(riop, line, MAXLINE)) < 0) {",,
"printf(""Failed to read header from remote server\n"");",0.0,"printf(""Failed to read header from remote server\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
// write to buffer,0.5,,// write to buffer,
"sprintf(header_buf, ""%s%s"", header_buf, line);",0.0,"sprintf(header_buf, ""%s%s"", header_buf, line);",,
// parse,0.5,,// parse,
"if (strcmp(""\r\n"", line) == 0)",0.0,"if (strcmp(""\r\n"", line) == 0)",,
break;,0.0,break;,,
if (count == 0) {,0.0,if (count == 0) {,,
"printf(""Reached EOF without seeing \\r\\n\n"");",0.0,"printf(""Reached EOF without seeing \\r\\n\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
"if (strncasecmp(""Content-Length"", line, 14) == 0) {",0.0,"if (strncasecmp(""Content-Length"", line, 14) == 0) {",,
// found,0.5,,// found,
int len;,0.0,int len;,,
"sscanf(line, ""%*[^:]: %d\r\n"", &len);",0.0,"sscanf(line, ""%*[^:]: %d\r\n"", &len);",,
*has_content_len = 1;,0.0,*has_content_len = 1;,,
*content_len = len;,0.0,*content_len = len;,,
},0.0,},,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
"* Read RIOP until EOF, and put content in to a buffer and point",1.0,,"* Read RIOP until EOF, and put content in to a buffer and point",
* BUFP to it.,1.0,,* BUFP to it.,
*,1.0,,*,
"* First allocate a buffer, and repeatly call rio_readnb until EOF, if",1.0,,"* First allocate a buffer, and repeatly call rio_readnb until EOF, if",
"* the content just read exceeds buffer's size, expand buffer to accommodate.",1.0,,"* the content just read exceeds buffer's size, expand buffer to accommodate.",
*/,0.0,*/,,
"size_t read_to_eof(rio_t *riop, char **bufp) {",0.0,"size_t read_to_eof(rio_t *riop, char **bufp) {",,
// tmp buffer,0.5,,// tmp buffer,
char buf[MAXBUF];,0.0,char buf[MAXBUF];,,
// returned buffer,0.5,,// returned buffer,
char *content_buf = malloc(MAXBUF);,0.0,char *content_buf = malloc(MAXBUF);,,
if (content_buf == NULL) {,0.0,if (content_buf == NULL) {,,
"printf(""malloc failed\n"");",0.0,"printf(""malloc failed\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
// how many bytes read,0.5,,// how many bytes read,
size_t count;,0.0,size_t count;,,
// position of cursor,0.5,,// position of cursor,
size_t pos = 0;,0.0,size_t pos = 0;,,
// position of cursor if we write buf to content_buf,0.5,,// position of cursor if we write buf to content_buf,
size_t newpos;,0.0,size_t newpos;,,
// current size of content_buf,0.5,,// current size of content_buf,
size_t bufsize = 0;,0.0,size_t bufsize = 0;,,
while (1) {,0.0,while (1) {,,
"count = rio_readnb(riop, buf, MAXBUF);",0.0,"count = rio_readnb(riop, buf, MAXBUF);",,
if (count == 0),0.0,if (count == 0),,
break;,0.0,break;,,
else if (count < 0) {,0.0,else if (count < 0) {,,
"printf(""Failed to read from remote server\n"");",0.0,"printf(""Failed to read from remote server\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
else {,0.0,else {,,
newpos = pos + count;,0.0,newpos = pos + count;,,
if (newpos > bufsize) {,0.0,if (newpos > bufsize) {,,
// need to grow buffer,0.5,,// need to grow buffer,
bufsize += MAXBUF;,0.0,bufsize += MAXBUF;,,
"char *newbuf = realloc(content_buf, bufsize);",0.0,"char *newbuf = realloc(content_buf, bufsize);",,
if (newbuf == NULL) {,0.0,if (newbuf == NULL) {,,
"printf(""Realloc failed\n"");",0.0,"printf(""Realloc failed\n"");",,
free(content_buf);,0.0,free(content_buf);,,
return -1;,0.0,return -1;,,
} else,0.0,} else,,
content_buf = newbuf;,0.0,content_buf = newbuf;,,
},0.0,},,
// copy buf to content_buf,0.5,,// copy buf to content_buf,
"memcpy(content_buf+pos, buf, count);",0.0,"memcpy(content_buf+pos, buf, count);",,
// update pos,0.5,,// update pos,
pos = newpos;,0.0,pos = newpos;,,
},0.0,},,
},0.0,},,
*bufp = content_buf;,0.0,*bufp = content_buf;,,
return pos;,0.0,return pos;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Read COUNT bytes from RIOP to BUFP.,1.0,,* Read COUNT bytes from RIOP to BUFP.,
*,1.0,,*,
* Simply read into BUFP until bytes_left is 0 or,1.0,,* Simply read into BUFP until bytes_left is 0 or,
* number of bytes read out = 0. And return number of read bytes.,1.0,,* number of bytes read out = 0. And return number of read bytes.,
*/,0.0,*/,,
"size_t read_bytes(rio_t *riop, char* bufp, size_t count) {",0.0,"size_t read_bytes(rio_t *riop, char* bufp, size_t count) {",,
// bytes left to read from remote server,0.5,,// bytes left to read from remote server,
size_t bytes_left = count;,0.0,size_t bytes_left = count;,,
size_t ncount;,0.0,size_t ncount;,,
while (1) {,0.0,while (1) {,,
"ncount = rio_readnb(riop, bufp, bytes_left);",0.0,"ncount = rio_readnb(riop, bufp, bytes_left);",,
bytes_left -= ncount;,0.0,bytes_left -= ncount;,,
if (ncount == 0),0.0,if (ncount == 0),,
break;,0.0,break;,,
else if (ncount < 0) {,0.0,else if (ncount < 0) {,,
"printf(""Read content failed\n"");",0.0,"printf(""Read content failed\n"");",,
return -1;,0.0,return -1;,,
},0.0,},,
},0.0,},,
return count - bytes_left;,0.0,return count - bytes_left;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Merge two chunks of memory P1 and P2 to gether into a new buffer and,1.0,,* Merge two chunks of memory P1 and P2 to gether into a new buffer and,
"* return the pointer to it. LEN1, LEN2 are the length of P1 and P2.",1.0,,"* return the pointer to it. LEN1, LEN2 are the length of P1 and P2.",
* Doesn鈥檛 P1 and P2 are not freed or anything.,1.0,,* Doesn鈥檛 P1 and P2 are not freed or anything.,
*,1.0,,*,
* Create a new buffer and memcpy p1 and p2 into it.,1.0,,* Create a new buffer and memcpy p1 and p2 into it.,
*/,0.0,*/,,
"char *merge_resp(char *p1, size_t len1, char *p2, size_t len2) {",0.0,"char *merge_resp(char *p1, size_t len1, char *p2, size_t len2) {",,
char *ret_buf = malloc(len1 + len2);,0.0,char *ret_buf = malloc(len1 + len2);,,
if (ret_buf == NULL) {,0.0,if (ret_buf == NULL) {,,
"printf(""malloc failed\n"");",0.0,"printf(""malloc failed\n"");",,
return NULL;,0.0,return NULL;,,
},0.0,},,
"memcpy(ret_buf, p1, len1);",0.0,"memcpy(ret_buf, p1, len1);",,
"memcpy(ret_buf+len1, p2, len2);",0.0,"memcpy(ret_buf+len1, p2, len2);",,
return ret_buf;,0.0,return ret_buf;,,
},0.0,},,
