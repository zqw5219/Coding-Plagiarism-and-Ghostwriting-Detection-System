originalCode,typeIndicator,pureCode,pureComment,pureMacro
/*,1.0,,/*,
* tsh - A tiny shell program with job control,1.0,,* tsh - A tiny shell program with job control,
*,1.0,,*,
* <Xing Chen xzc5179>,1.0,,* <Xing Chen xzc5179>,
*/,0.0,*/,,
#include <stdio.h>,0.0,#include <stdio.h>,,
#include <stdlib.h>,0.0,#include <stdlib.h>,,
#include <unistd.h>,0.0,#include <unistd.h>,,
#include <string.h>,0.0,#include <string.h>,,
#include <ctype.h>,0.0,#include <ctype.h>,,
#include <signal.h>,0.0,#include <signal.h>,,
#include <sys/types.h>,0.0,#include <sys/types.h>,,
#include <sys/wait.h>,0.0,#include <sys/wait.h>,,
#include <errno.h>,0.0,#include <errno.h>,,
,0.0,,,
/* Misc manifest constants */,1.0,,/* Misc manifest constants */,
#define MAXLINE    1024   /* max line size */,1.0,,#define MAXLINE    1024   /* max line size */,
#define MAXARGS     128   /* max args on a command line */,1.0,,#define MAXARGS     128   /* max args on a command line */,
#define MAXJOBS      16   /* max jobs at any point in time */,1.0,,#define MAXJOBS      16   /* max jobs at any point in time */,
#define MAXJID    1<<16   /* max job ID */,1.0,,#define MAXJID    1<<16   /* max job ID */,
,0.0,,,
/* Job states */,1.0,,/* Job states */,
#define UNDEF 0 /* undefined */,1.0,,#define UNDEF 0 /* undefined */,
#define FG 1    /* running in foreground */,1.0,,#define FG 1    /* running in foreground */,
#define BG 2    /* running in background */,1.0,,#define BG 2    /* running in background */,
#define ST 3    /* stopped */,1.0,,#define ST 3    /* stopped */,
,0.0,,,
/*,1.0,,/*,
"* Jobs states: FG (foreground), BG (background), ST (stopped)",1.0,,"* Jobs states: FG (foreground), BG (background), ST (stopped)",
* Job state transitions and enabling actions:,1.0,,* Job state transitions and enabling actions:,
*     FG -> ST  : ctrl-z,1.0,,*     FG -> ST  : ctrl-z,
*     ST -> FG  : fg command,1.0,,*     ST -> FG  : fg command,
*     ST -> BG  : bg command,1.0,,*     ST -> BG  : bg command,
*     BG -> FG  : fg command,1.0,,*     BG -> FG  : fg command,
* At most 1 job can be in the FG state.,1.0,,* At most 1 job can be in the FG state.,
*/,0.0,*/,,
,0.0,,,
/* Global variables */,1.0,,/* Global variables */,
extern char **environ;      /* defined in libc */,1.0,,extern char **environ;      /* defined in libc */,
"char prompt[] = ""tsh> "";    /* command line prompt (DO NOT CHANGE) */",1.0,,"char prompt[] = ""tsh> "";    /* command line prompt (DO NOT CHANGE) */",
"int verbose = 0;            /* if true, print additional output */",1.0,,"int verbose = 0;            /* if true, print additional output */",
int nextjid = 1;            /* next job ID to allocate */,1.0,,int nextjid = 1;            /* next job ID to allocate */,
char sbuf[MAXLINE];         /* for composing sprintf messages */,1.0,,char sbuf[MAXLINE];         /* for composing sprintf messages */,
,0.0,,,
struct job_t {              /* The job struct */,1.0,,struct job_t {              /* The job struct */,
pid_t pid;              /* job PID */,1.0,,pid_t pid;              /* job PID */,
"int jid;                /* job ID [1, 2, ...] */",1.0,,"int jid;                /* job ID [1, 2, ...] */",
"int state;              /* UNDEF, BG, FG, or ST */",1.0,,"int state;              /* UNDEF, BG, FG, or ST */",
char cmdline[MAXLINE];  /* command line */,1.0,,char cmdline[MAXLINE];  /* command line */,
};,0.0,};,,
struct job_t jobs[MAXJOBS]; /* The job list */,1.0,,struct job_t jobs[MAXJOBS]; /* The job list */,
/* End global variables */,1.0,,/* End global variables */,
,0.0,,,
,0.0,,,
/* Function prototypes */,1.0,,/* Function prototypes */,
,0.0,,,
/* Here are the functions that you will implement */,1.0,,/* Here are the functions that you will implement */,
void eval(char *cmdline);,0.0,void eval(char *cmdline);,,
int builtin_cmd(char **argv);,0.0,int builtin_cmd(char **argv);,,
void do_bgfg(char **argv);,0.0,void do_bgfg(char **argv);,,
void waitfg(pid_t pid);,0.0,void waitfg(pid_t pid);,,
,0.0,,,
void sigchld_handler(int sig);,0.0,void sigchld_handler(int sig);,,
void sigtstp_handler(int sig);,0.0,void sigtstp_handler(int sig);,,
void sigint_handler(int sig);,0.0,void sigint_handler(int sig);,,
,0.0,,,
/* Here are helper routines that we've provided for you */,1.0,,/* Here are helper routines that we've provided for you */,
"int parseline(const char *cmdline, char **argv);",0.0,"int parseline(const char *cmdline, char **argv);",,
void sigquit_handler(int sig);,0.0,void sigquit_handler(int sig);,,
,0.0,,,
void clearjob(struct job_t *job);,0.0,void clearjob(struct job_t *job);,,
void initjobs(struct job_t *jobs);,0.0,void initjobs(struct job_t *jobs);,,
int maxjid(struct job_t *jobs);,0.0,int maxjid(struct job_t *jobs);,,
"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);",0.0,"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);",,
"int deletejob(struct job_t *jobs, pid_t pid);",0.0,"int deletejob(struct job_t *jobs, pid_t pid);",,
pid_t fgpid(struct job_t *jobs);,0.0,pid_t fgpid(struct job_t *jobs);,,
"struct job_t *getjobpid(struct job_t *jobs, pid_t pid);",0.0,"struct job_t *getjobpid(struct job_t *jobs, pid_t pid);",,
"struct job_t *getjobjid(struct job_t *jobs, int jid);",0.0,"struct job_t *getjobjid(struct job_t *jobs, int jid);",,
int pid2jid(pid_t pid);,0.0,int pid2jid(pid_t pid);,,
void listjobs(struct job_t *jobs);,0.0,void listjobs(struct job_t *jobs);,,
,0.0,,,
void usage(void);,0.0,void usage(void);,,
void unix_error(char *msg);,0.0,void unix_error(char *msg);,,
void app_error(char *msg);,0.0,void app_error(char *msg);,,
typedef void handler_t(int);,0.0,typedef void handler_t(int);,,
"handler_t *Signal(int signum, handler_t *handler);",0.0,"handler_t *Signal(int signum, handler_t *handler);",,
,0.0,,,
/*,1.0,,/*,
* main - The shell's main routine,1.0,,* main - The shell's main routine,
*/,0.0,*/,,
"int main(int argc, char **argv)",0.0,"int main(int argc, char **argv)",,
{,0.0,{,,
char c;,0.0,char c;,,
char cmdline[MAXLINE];,0.0,char cmdline[MAXLINE];,,
int emit_prompt = 1; /* emit prompt (default) */,1.0,,int emit_prompt = 1; /* emit prompt (default) */,
,0.0,,,
/* Redirect stderr to stdout (so that driver will get all output,1.0,,/* Redirect stderr to stdout (so that driver will get all output,
* on the pipe connected to stdout) */,0.0,* on the pipe connected to stdout) */,,
"dup2(1, 2);",0.0,"dup2(1, 2);",,
,0.0,,,
/* Parse the command line */,1.0,,/* Parse the command line */,
"while ((c = getopt(argc, argv, ""hvp"")) != EOF) {",0.0,"while ((c = getopt(argc, argv, ""hvp"")) != EOF) {",,
switch (c) {,0.0,switch (c) {,,
case 'h':             /* print help message */,1.0,,case 'h':             /* print help message */,
usage();,0.0,usage();,,
break;,0.0,break;,,
case 'v':             /* emit additional diagnostic info */,1.0,,case 'v':             /* emit additional diagnostic info */,
verbose = 1;,0.0,verbose = 1;,,
break;,0.0,break;,,
case 'p':             /* don't print a prompt */,1.0,,case 'p':             /* don't print a prompt */,
emit_prompt = 0;  /* handy for automatic testing */,1.0,,emit_prompt = 0;  /* handy for automatic testing */,
break;,0.0,break;,,
default:,0.0,default:,,
usage();,0.0,usage();,,
},0.0,},,
},0.0,},,
,0.0,,,
/* Install the signal handlers */,1.0,,/* Install the signal handlers */,
,0.0,,,
/* These are the ones you will need to implement */,1.0,,/* These are the ones you will need to implement */,
"Signal(SIGINT,  sigint_handler);   /* ctrl-c */",1.0,,"Signal(SIGINT,  sigint_handler);   /* ctrl-c */",
"Signal(SIGTSTP, sigtstp_handler);  /* ctrl-z */",1.0,,"Signal(SIGTSTP, sigtstp_handler);  /* ctrl-z */",
"Signal(SIGCHLD, sigchld_handler);  /* Terminated or stopped child */",1.0,,"Signal(SIGCHLD, sigchld_handler);  /* Terminated or stopped child */",
,0.0,,,
/* This one provides a clean way to kill the shell */,1.0,,/* This one provides a clean way to kill the shell */,
"Signal(SIGQUIT, sigquit_handler);",0.0,"Signal(SIGQUIT, sigquit_handler);",,
,0.0,,,
/* Initialize the job list */,1.0,,/* Initialize the job list */,
initjobs(jobs);,0.0,initjobs(jobs);,,
,0.0,,,
/* Execute the shell's read/eval loop */,1.0,,/* Execute the shell's read/eval loop */,
while (1) {,0.0,while (1) {,,
,0.0,,,
/* Read command line */,1.0,,/* Read command line */,
if (emit_prompt) {,0.0,if (emit_prompt) {,,
"printf(""%s"", prompt);",0.0,"printf(""%s"", prompt);",,
fflush(stdout);,0.0,fflush(stdout);,,
},0.0,},,
"if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))",0.0,"if ((fgets(cmdline, MAXLINE, stdin) == NULL) && ferror(stdin))",,
"app_error(""fgets error"");",0.0,"app_error(""fgets error"");",,
if (feof(stdin)) { /* End of file (ctrl-d) */,1.0,,if (feof(stdin)) { /* End of file (ctrl-d) */,
fflush(stdout);,0.0,fflush(stdout);,,
exit(0);,0.0,exit(0);,,
},0.0,},,
,0.0,,,
/* Evaluate the command line */,1.0,,/* Evaluate the command line */,
eval(cmdline);,0.0,eval(cmdline);,,
fflush(stdout);,0.0,fflush(stdout);,,
fflush(stdout);,0.0,fflush(stdout);,,
},0.0,},,
,0.0,,,
exit(0); /* control never reaches here */,1.0,,exit(0); /* control never reaches here */,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* eval - Evaluate the command line that the user has just typed in,1.0,,* eval - Evaluate the command line that the user has just typed in,
*,1.0,,*,
"* If the user has requested a built-in command (quit, jobs, bg or fg)",1.0,,"* If the user has requested a built-in command (quit, jobs, bg or fg)",
"* then execute it immediately. Otherwise, fork a child process and",1.0,,"* then execute it immediately. Otherwise, fork a child process and",
* run the job in the context of the child. If the job is running in,1.0,,* run the job in the context of the child. If the job is running in,
"* the foreground, wait for it to terminate and then return.  Note:",1.0,,"* the foreground, wait for it to terminate and then return.  Note:",
* each child process must have a unique process group ID so that our,1.0,,* each child process must have a unique process group ID so that our,
* background children don't receive SIGINT (SIGTSTP) from the kernel,1.0,,* background children don't receive SIGINT (SIGTSTP) from the kernel,
* when we type ctrl-c (ctrl-z) at the keyboard.,1.0,,* when we type ctrl-c (ctrl-z) at the keyboard.,
*/,0.0,*/,,
void eval(char *cmdline),0.0,void eval(char *cmdline),,
{,0.0,{,,
char *argv[MAXARGS];,0.0,char *argv[MAXARGS];,,
char buf[MAXLINE];,0.0,char buf[MAXLINE];,,
sigset_t mask;,0.0,sigset_t mask;,,
"strcpy(buf,cmdline);",0.0,"strcpy(buf,cmdline);",,
"int backg = parseline(buf,argv);",0.0,"int backg = parseline(buf,argv);",,
pid_t pid;,0.0,pid_t pid;,,
//check if the argument is NULL or not,0.5,,//check if the argument is NULL or not,
if (argv[0] ==NULL),0.0,if (argv[0] ==NULL),,
return;,0.0,return;,,
if (builtin_cmd(argv)){,0.0,if (builtin_cmd(argv)){,,
return;,0.0,return;,,
},0.0,},,
else,0.0,else,,
{,0.0,{,,
//Block the SIGCHLD signal,0.5,,//Block the SIGCHLD signal,
sigemptyset(&mask);,0.0,sigemptyset(&mask);,,
"sigaddset(&mask,SIGCHLD);",0.0,"sigaddset(&mask,SIGCHLD);",,
"sigprocmask(SIG_BLOCK,&mask,NULL);",0.0,"sigprocmask(SIG_BLOCK,&mask,NULL);",,
,0.0,,,
// Fork a child process and excute it,0.5,,// Fork a child process and excute it,
pid = fork();,0.0,pid = fork();,,
if(pid == 0),0.0,if(pid == 0),,
{,0.0,{,,
"setpgid(0,0);",0.0,"setpgid(0,0);",,
"sigprocmask(SIG_UNBLOCK,&mask,NULL);",0.0,"sigprocmask(SIG_UNBLOCK,&mask,NULL);",,
"if (execve(argv[0],argv,environ )<0){",0.0,"if (execve(argv[0],argv,environ )<0){",,
"printf(""%s: Command not found\n"",argv[0]);",0.0,"printf(""%s: Command not found\n"",argv[0]);",,
exit(0);,0.0,exit(0);,,
},0.0,},,
},0.0,},,
else,0.0,else,,
{,0.0,{,,
"// if it is fg jobe, add it to the FGjoblist",0.5,,"// if it is fg jobe, add it to the FGjoblist",
// else add it to the BGjoblist,0.5,,// else add it to the BGjoblist,
if (!backg) {,0.0,if (!backg) {,,
"addjob(jobs,pid,FG,cmdline);",0.0,"addjob(jobs,pid,FG,cmdline);",,
},0.0,},,
else {,0.0,else {,,
"addjob(jobs,pid,BG,cmdline);",0.0,"addjob(jobs,pid,BG,cmdline);",,
},0.0,},,
,0.0,,,
"sigprocmask(SIG_UNBLOCK,&mask,NULL);",0.0,"sigprocmask(SIG_UNBLOCK,&mask,NULL);",,
,0.0,,,
if (!backg),0.0,if (!backg),,
{,0.0,{,,
waitfg(pid);,0.0,waitfg(pid);,,
},0.0,},,
else,0.0,else,,
{,0.0,{,,
,0.0,,,
"printf(""[%d] (%d) %s"", pid2jid(pid),pid,cmdline);",0.0,"printf(""[%d] (%d) %s"", pid2jid(pid),pid,cmdline);",,
},0.0,},,
,0.0,,,
},0.0,},,
},0.0,},,
,0.0,,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* parseline - Parse the command line and build the argv array.,1.0,,* parseline - Parse the command line and build the argv array.,
*,1.0,,*,
* Characters enclosed in single quotes are treated as a single,1.0,,* Characters enclosed in single quotes are treated as a single,
"* argument.  Return true if the user has requested a BG job, false if",1.0,,"* argument.  Return true if the user has requested a BG job, false if",
* the user has requested a FG job.,1.0,,* the user has requested a FG job.,
*/,0.0,*/,,
"int parseline(const char *cmdline, char **argv)",0.0,"int parseline(const char *cmdline, char **argv)",,
{,0.0,{,,
static char array[MAXLINE]; /* holds local copy of command line */,1.0,,static char array[MAXLINE]; /* holds local copy of command line */,
char *buf = array;          /* ptr that traverses command line */,1.0,,char *buf = array;          /* ptr that traverses command line */,
char *delim;                /* points to first space delimiter */,1.0,,char *delim;                /* points to first space delimiter */,
int argc;                   /* number of args */,1.0,,int argc;                   /* number of args */,
int bg;                     /* background job? */,1.0,,int bg;                     /* background job? */,
,0.0,,,
,0.0,,,
"strcpy(buf, cmdline);",0.0,"strcpy(buf, cmdline);",,
buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */,1.0,,buf[strlen(buf)-1] = ' ';  /* replace trailing '\n' with space */,
while (*buf && (*buf == ' ')) /* ignore leading spaces */,1.0,,while (*buf && (*buf == ' ')) /* ignore leading spaces */,
buf++;,0.0,buf++;,,
,0.0,,,
/* Build the argv list */,1.0,,/* Build the argv list */,
argc = 0;,0.0,argc = 0;,,
if (*buf == '\'') {,0.0,if (*buf == '\'') {,,
buf++;,0.0,buf++;,,
"delim = strchr(buf, '\'');",0.0,"delim = strchr(buf, '\'');",,
},0.0,},,
else {,0.0,else {,,
"delim = strchr(buf, ' ');",0.0,"delim = strchr(buf, ' ');",,
},0.0,},,
,0.0,,,
while (argc < MAXARGS-1 && delim) {,0.0,while (argc < MAXARGS-1 && delim) {,,
argv[argc++] = buf;,0.0,argv[argc++] = buf;,,
*delim = '\0';,0.0,*delim = '\0';,,
buf = delim + 1;,0.0,buf = delim + 1;,,
while (*buf && (*buf == ' ')) /* ignore spaces */,1.0,,while (*buf && (*buf == ' ')) /* ignore spaces */,
buf++;,0.0,buf++;,,
,0.0,,,
if (*buf == '\'') {,0.0,if (*buf == '\'') {,,
buf++;,0.0,buf++;,,
"delim = strchr(buf, '\'');",0.0,"delim = strchr(buf, '\'');",,
},0.0,},,
else {,0.0,else {,,
"delim = strchr(buf, ' ');",0.0,"delim = strchr(buf, ' ');",,
},0.0,},,
},0.0,},,
if (delim) {,0.0,if (delim) {,,
"fprintf(stderr, ""Too many arguments.\n"");",0.0,"fprintf(stderr, ""Too many arguments.\n"");",,
argc = 0; //treat it as an empty line.,0.5,argc = 0; ,//treat it as an empty line.,
},0.0,},,
argv[argc] = NULL;,0.0,argv[argc] = NULL;,,
,0.0,,,
if (argc == 0)  /* ignore blank line */,1.0,,if (argc == 0)  /* ignore blank line */,
return 1;,0.0,return 1;,,
,0.0,,,
/* should the job run in the background? */,1.0,,/* should the job run in the background? */,
if ((bg = (*argv[argc-1] == '&')) != 0) {,0.0,if ((bg = (*argv[argc-1] == '&')) != 0) {,,
argv[--argc] = NULL;,0.0,argv[--argc] = NULL;,,
},0.0,},,
return bg;,0.0,return bg;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* builtin_cmd - If the user has typed a built-in command then execute,1.0,,* builtin_cmd - If the user has typed a built-in command then execute,
*    it immediately.,1.0,,*    it immediately.,
*/,0.0,*/,,
int builtin_cmd(char **argv),0.0,int builtin_cmd(char **argv),,
{,0.0,{,,
"// check for commond line start with quit,jobs,fg bg or &",0.5,,"// check for commond line start with quit,jobs,fg bg or &",
char *comd= argv[0];,0.0,char *comd= argv[0];,,
"if (strcmp(comd,""quit"")==0){",0.0,"if (strcmp(comd,""quit"")==0){",,
exit(0);,0.0,exit(0);,,
},0.0,},,
"if (strcmp(comd, ""jobs"") ==0 ){",0.0,"if (strcmp(comd, ""jobs"") ==0 ){",,
listjobs(jobs);,0.0,listjobs(jobs);,,
return 1;,0.0,return 1;,,
},0.0,},,
"if (strcmp(comd,""fg"") == 0 || strcmp(comd,""bg"")==0){",0.0,"if (strcmp(comd,""fg"") == 0 || strcmp(comd,""bg"")==0){",,
do_bgfg(argv);,0.0,do_bgfg(argv);,,
return 1;,0.0,return 1;,,
},0.0,},,
"else if (strcmp(comd,""&"")==0 )",0.0,"else if (strcmp(comd,""&"")==0 )",,
{,0.0,{,,
return 1;,0.0,return 1;,,
},0.0,},,
return 0 ;,0.0,return 0 ;,,
},0.0,},,
,0.0,,,
void do_bgfg(char **argv),0.0,void do_bgfg(char **argv),,
{,0.0,{,,
char *sec=argv[1];,0.0,char *sec=argv[1];,,
int jid;,0.0,int jid;,,
pid_t pid;,0.0,pid_t pid;,,
struct job_t *job;,0.0,struct job_t *job;,,
// check if the bg or fg have second argument,0.5,,// check if the bg or fg have second argument,
if (sec == NULL),0.0,if (sec == NULL),,
{,0.0,{,,
"printf(""%s command requires PID or %%jobid argument\n"", argv[0]);",0.0,"printf(""%s command requires PID or %%jobid argument\n"", argv[0]);",,
return;,0.0,return;,,
},0.0,},,
"// if it start with %, then it is a jid",0.5,,"// if it start with %, then it is a jid",
// else will be a pid,0.5,,// else will be a pid,
if (sec[0] == '%'),0.0,if (sec[0] == '%'),,
{,0.0,{,,
//convert the string to int,0.5,,//convert the string to int,
//check if the jid or pid match the real one,0.5,,//check if the jid or pid match the real one,
//return message if not match,0.5,,//return message if not match,
jid=atoi(&sec[1]);,0.0,jid=atoi(&sec[1]);,,
,0.0,,,
"job=getjobjid(jobs,jid);",0.0,"job=getjobjid(jobs,jid);",,
if (job == NULL),0.0,if (job == NULL),,
{,0.0,{,,
"printf(""%s: No such job\n"",sec);",0.0,"printf(""%s: No such job\n"",sec);",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
},0.0,},,
else,0.0,else,,
{,0.0,{,,
//check if the argument is number or not,0.5,,//check if the argument is number or not,
if (!isdigit(sec[0])),0.0,if (!isdigit(sec[0])),,
{,0.0,{,,
"printf(""%s: argument must be a PID or %%jobid\n"",argv[0]);",0.0,"printf(""%s: argument must be a PID or %%jobid\n"",argv[0]);",,
return;,0.0,return;,,
},0.0,},,
pid = (pid_t)atoi(sec);,0.0,pid = (pid_t)atoi(sec);,,
"job = getjobpid(jobs,pid);",0.0,"job = getjobpid(jobs,pid);",,
if (job==NULL),0.0,if (job==NULL),,
{,0.0,{,,
"printf(""(%s): No such process\n"",sec);",0.0,"printf(""(%s): No such process\n"",sec);",,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
},0.0,},,
,0.0,,,
,0.0,,,
//check fg or bg then set the state,0.5,,//check fg or bg then set the state,
char *first= argv[0];,0.0,char *first= argv[0];,,
"//printf(""%s"",first);",0.5,,"//printf(""%s"",first);",
pid=job->pid;,0.0,pid=job->pid;,,
jid=job->jid;,0.0,jid=job->jid;,,
,0.0,,,
"if (strcmp(first,""fg"") == 0)",0.0,"if (strcmp(first,""fg"") == 0)",,
{,0.0,{,,
,0.0,,,
if(job->state == ST),0.0,if(job->state == ST),,
{,0.0,{,,
"kill(-pid,SIGCONT);",0.0,"kill(-pid,SIGCONT);",,
job->state = BG;,0.0,job->state = BG;,,
},0.0,},,
if (job->state == BG),0.0,if (job->state == BG),,
{,0.0,{,,
job->state=FG;,0.0,job->state=FG;,,
waitfg(pid);,0.0,waitfg(pid);,,
},0.0,},,
},0.0,},,
else,0.0,else,,
{,0.0,{,,
job->state =BG;,0.0,job->state =BG;,,
"kill(-pid,SIGCONT);",0.0,"kill(-pid,SIGCONT);",,
"printf(""[%d] (%d) %s"",jid,pid,job->cmdline);",0.0,"printf(""[%d] (%d) %s"",jid,pid,job->cmdline);",,
},0.0,},,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
void waitfg(pid_t pid),0.0,void waitfg(pid_t pid),,
{,0.0,{,,
"struct job_t *job = getjobpid(jobs,pid);",0.0,"struct job_t *job = getjobpid(jobs,pid);",,
// checking the FG state,0.5,,// checking the FG state,
while(job->state == FG){,0.0,while(job->state == FG){,,
sleep(1);,0.0,sleep(1);,,
},0.0,},,
return;,0.0,return;,,
,0.0,,,
,0.0,,,
},0.0,},,
"/*     available zombie children, but doesn't wait for any other",1.0,,"/*     available zombie children, but doesn't wait for any other",
*     currently running children to terminate.,1.0,,*     currently running children to terminate.,
*/,0.0,*/,,
void sigchld_handler(int sig),0.0,void sigchld_handler(int sig),,
{,0.0,{,,
pid_t pid;,0.0,pid_t pid;,,
int stat;,0.0,int stat;,,
struct job_t *job;,0.0,struct job_t *job;,,
"if ((pid = waitpid(-1,&stat,WUNTRACED | WNOHANG))>0)",0.0,"if ((pid = waitpid(-1,&stat,WUNTRACED | WNOHANG))>0)",,
{,0.0,{,,
"job = getjobpid(jobs,pid);",0.0,"job = getjobpid(jobs,pid);",,
//if the process is stopped by quit,0.5,,//if the process is stopped by quit,
if (WIFEXITED(stat) ),0.0,if (WIFEXITED(stat) ),,
{,0.0,{,,
"deletejob(jobs,pid);",0.0,"deletejob(jobs,pid);",,
,0.0,,,
},0.0,},,
//if the process is stopped by signal,0.5,,//if the process is stopped by signal,
else if (WIFSIGNALED(stat)),0.0,else if (WIFSIGNALED(stat)),,
{,0.0,{,,
"printf(""Job [%d] (%d) terminated by signal %d\n"",pid2jid(pid),pid,WTERMSIG(stat));",0.0,"printf(""Job [%d] (%d) terminated by signal %d\n"",pid2jid(pid),pid,WTERMSIG(stat));",,
"deletejob(jobs,pid);",0.0,"deletejob(jobs,pid);",,
,0.0,,,
},0.0,},,
else if(WIFSTOPPED(stat)),0.0,else if(WIFSTOPPED(stat)),,
{,0.0,{,,
job->state =ST;,0.0,job->state =ST;,,
"printf(""Job [%d] (%d) stopped by signal %d\n"",pid2jid(pid),pid,WSTOPSIG(stat));",0.0,"printf(""Job [%d] (%d) stopped by signal %d\n"",pid2jid(pid),pid,WSTOPSIG(stat));",,
},0.0,},,
else if (WIFCONTINUED(stat)),0.0,else if (WIFCONTINUED(stat)),,
{,0.0,{,,
job->state =BG;,0.0,job->state =BG;,,
},0.0,},,
},0.0,},,
,0.0,,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigint_handler - The kernel sends a SIGINT to the shell whenver the,1.0,,* sigint_handler - The kernel sends a SIGINT to the shell whenver the,
*    user types ctrl-c at the keyboard.  Catch it and send it along,1.0,,*    user types ctrl-c at the keyboard.  Catch it and send it along,
*    to the foreground job.,1.0,,*    to the foreground job.,
*/,0.0,*/,,
void sigint_handler(int sig),0.0,void sigint_handler(int sig),,
{,0.0,{,,
pid_t pid= fgpid(jobs);,0.0,pid_t pid= fgpid(jobs);,,
,0.0,,,
,0.0,,,
//sent the signal when the pid is 0,0.5,,//sent the signal when the pid is 0,
if (pid!=0 ),0.0,if (pid!=0 ),,
{,0.0,{,,
,0.0,,,
"kill(-pid,SIGINT);",0.0,"kill(-pid,SIGINT);",,
},0.0,},,
,0.0,,,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever,1.0,,* sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever,
*     the user types ctrl-z at the keyboard. Catch it and suspend the,1.0,,*     the user types ctrl-z at the keyboard. Catch it and suspend the,
*     foreground job by sending it a SIGTSTP.,1.0,,*     foreground job by sending it a SIGTSTP.,
*/,0.0,*/,,
void sigtstp_handler(int sig),0.0,void sigtstp_handler(int sig),,
{,0.0,{,,
pid_t pid = fgpid(jobs);,0.0,pid_t pid = fgpid(jobs);,,
//sent the signal when it stopped by ctrl-z,0.5,,//sent the signal when it stopped by ctrl-z,
if(pid!=0),0.0,if(pid!=0),,
{,0.0,{,,
,0.0,,,
"kill(-pid,SIGTSTP);",0.0,"kill(-pid,SIGTSTP);",,
,0.0,,,
},0.0,},,
return;,0.0,return;,,
},0.0,},,
,0.0,,,
/*********************,1.0,,/*********************,
* End signal handlers,1.0,,* End signal handlers,
*********************/,0.0,*********************/,,
,0.0,,,
/***********************************************,1.0,,/***********************************************,
* Helper routines that manipulate the job list,1.0,,* Helper routines that manipulate the job list,
**********************************************/,0.0,**********************************************/,,
,0.0,,,
/* clearjob - Clear the entries in a job struct */,1.0,,/* clearjob - Clear the entries in a job struct */,
void clearjob(struct job_t *job) {,0.0,void clearjob(struct job_t *job) {,,
job->pid = 0;,0.0,job->pid = 0;,,
job->jid = 0;,0.0,job->jid = 0;,,
job->state = UNDEF;,0.0,job->state = UNDEF;,,
job->cmdline[0] = '\0';,0.0,job->cmdline[0] = '\0';,,
},0.0,},,
,0.0,,,
/* initjobs - Initialize the job list */,1.0,,/* initjobs - Initialize the job list */,
void initjobs(struct job_t *jobs) {,0.0,void initjobs(struct job_t *jobs) {,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
clearjob(&jobs[i]);,0.0,clearjob(&jobs[i]);,,
},0.0,},,
,0.0,,,
/* maxjid - Returns largest allocated job ID */,1.0,,/* maxjid - Returns largest allocated job ID */,
int maxjid(struct job_t *jobs),0.0,int maxjid(struct job_t *jobs),,
{,0.0,{,,
"int i, max=0;",0.0,"int i, max=0;",,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].jid > max),0.0,if (jobs[i].jid > max),,
max = jobs[i].jid;,0.0,max = jobs[i].jid;,,
return max;,0.0,return max;,,
},0.0,},,
,0.0,,,
/* addjob - Add a job to the job list */,1.0,,/* addjob - Add a job to the job list */,
"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline)",0.0,"int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid == 0) {,0.0,if (jobs[i].pid == 0) {,,
jobs[i].pid = pid;,0.0,jobs[i].pid = pid;,,
jobs[i].state = state;,0.0,jobs[i].state = state;,,
jobs[i].jid = nextjid++;,0.0,jobs[i].jid = nextjid++;,,
if (nextjid > MAXJOBS),0.0,if (nextjid > MAXJOBS),,
nextjid = 1;,0.0,nextjid = 1;,,
"strcpy(jobs[i].cmdline, cmdline);",0.0,"strcpy(jobs[i].cmdline, cmdline);",,
if(verbose){,0.0,if(verbose){,,
"printf(""Added job [%d] %d %s\n"", jobs[i].jid, jobs[i].pid, jobs[i].cmdline);",0.0,"printf(""Added job [%d] %d %s\n"", jobs[i].jid, jobs[i].pid, jobs[i].cmdline);",,
},0.0,},,
return 1;,0.0,return 1;,,
},0.0,},,
},0.0,},,
"printf(""Tried to create too many jobs\n"");",0.0,"printf(""Tried to create too many jobs\n"");",,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/* deletejob - Delete a job whose PID=pid from the job list */,1.0,,/* deletejob - Delete a job whose PID=pid from the job list */,
"int deletejob(struct job_t *jobs, pid_t pid)",0.0,"int deletejob(struct job_t *jobs, pid_t pid)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid == pid) {,0.0,if (jobs[i].pid == pid) {,,
clearjob(&jobs[i]);,0.0,clearjob(&jobs[i]);,,
nextjid = maxjid(jobs)+1;,0.0,nextjid = maxjid(jobs)+1;,,
return 1;,0.0,return 1;,,
},0.0,},,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
"/* fgpid - Return PID of current foreground job, 0 if no such job */",1.0,,"/* fgpid - Return PID of current foreground job, 0 if no such job */",
pid_t fgpid(struct job_t *jobs) {,0.0,pid_t fgpid(struct job_t *jobs) {,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].state == FG),0.0,if (jobs[i].state == FG),,
return jobs[i].pid;,0.0,return jobs[i].pid;,,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
/* getjobpid  - Find a job (by PID) on the job list */,1.0,,/* getjobpid  - Find a job (by PID) on the job list */,
"struct job_t *getjobpid(struct job_t *jobs, pid_t pid) {",0.0,"struct job_t *getjobpid(struct job_t *jobs, pid_t pid) {",,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return NULL;,0.0,return NULL;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].pid == pid),0.0,if (jobs[i].pid == pid),,
return &jobs[i];,0.0,return &jobs[i];,,
return NULL;,0.0,return NULL;,,
},0.0,},,
,0.0,,,
,0.0,,,
"struct job_t *getjobjid(struct job_t *jobs, int jid)",0.0,"struct job_t *getjobjid(struct job_t *jobs, int jid)",,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (jid < 1),0.0,if (jid < 1),,
return NULL;,0.0,return NULL;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].jid == jid),0.0,if (jobs[i].jid == jid),,
return &jobs[i];,0.0,return &jobs[i];,,
return NULL;,0.0,return NULL;,,
},0.0,},,
,0.0,,,
/* pid2jid - Map process ID to job ID */,1.0,,/* pid2jid - Map process ID to job ID */,
int pid2jid(pid_t pid),0.0,int pid2jid(pid_t pid),,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
if (pid < 1),0.0,if (pid < 1),,
return 0;,0.0,return 0;,,
for (i = 0; i < MAXJOBS; i++),0.0,for (i = 0; i < MAXJOBS; i++),,
if (jobs[i].pid == pid) {,0.0,if (jobs[i].pid == pid) {,,
return jobs[i].jid;,0.0,return jobs[i].jid;,,
},0.0,},,
return 0;,0.0,return 0;,,
},0.0,},,
,0.0,,,
,0.0,,,
,0.0,,,
,0.0,,,
,0.0,,,
/* listjobs - Print the job list */,1.0,,/* listjobs - Print the job list */,
void listjobs(struct job_t *jobs),0.0,void listjobs(struct job_t *jobs),,
{,0.0,{,,
int i;,0.0,int i;,,
,0.0,,,
for (i = 0; i < MAXJOBS; i++) {,0.0,for (i = 0; i < MAXJOBS; i++) {,,
if (jobs[i].pid != 0) {,0.0,if (jobs[i].pid != 0) {,,
"printf(""[%d] (%d) "", jobs[i].jid, jobs[i].pid);",0.0,"printf(""[%d] (%d) "", jobs[i].jid, jobs[i].pid);",,
switch (jobs[i].state) {,0.0,switch (jobs[i].state) {,,
case BG:,0.0,case BG:,,
"printf(""Running "");",0.0,"printf(""Running "");",,
break;,0.0,break;,,
case FG:,0.0,case FG:,,
"printf(""Foreground "");",0.0,"printf(""Foreground "");",,
break;,0.0,break;,,
case ST:,0.0,case ST:,,
"printf(""Stopped "");",0.0,"printf(""Stopped "");",,
break;,0.0,break;,,
default:,0.0,default:,,
"printf(""listjobs: Internal error: job[%d].state=%d "",",0.0,"printf(""listjobs: Internal error: job[%d].state=%d "",",,
"i, jobs[i].state);",0.0,"i, jobs[i].state);",,
},0.0,},,
"printf(""%s"", jobs[i].cmdline);",0.0,"printf(""%s"", jobs[i].cmdline);",,
},0.0,},,
},0.0,},,
},0.0,},,
/******************************,1.0,,/******************************,
* end job list helper routines,1.0,,* end job list helper routines,
******************************/,0.0,******************************/,,
,0.0,,,
,0.0,,,
/***********************,1.0,,/***********************,
* Other helper routines,1.0,,* Other helper routines,
***********************/,0.0,***********************/,,
,0.0,,,
/*,1.0,,/*,
* usage - print a help message,1.0,,* usage - print a help message,
*/,0.0,*/,,
void usage(void),0.0,void usage(void),,
{,0.0,{,,
"printf(""Usage: shell [-hvp]\n"");",0.0,"printf(""Usage: shell [-hvp]\n"");",,
"printf(""   -h   print this message\n"");",0.0,"printf(""   -h   print this message\n"");",,
"printf(""   -v   print additional diagnostic information\n"");",0.0,"printf(""   -v   print additional diagnostic information\n"");",,
"printf(""   -p   do not emit a command prompt\n"");",0.0,"printf(""   -p   do not emit a command prompt\n"");",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* unix_error - unix-style error routine,1.0,,* unix_error - unix-style error routine,
*/,0.0,*/,,
void unix_error(char *msg),0.0,void unix_error(char *msg),,
{,0.0,{,,
"fprintf(stdout, ""%s: %s\n"", msg, strerror(errno));",0.0,"fprintf(stdout, ""%s: %s\n"", msg, strerror(errno));",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* app_error - application-style error routine,1.0,,* app_error - application-style error routine,
*/,0.0,*/,,
void app_error(char *msg),0.0,void app_error(char *msg),,
{,0.0,{,,
"fprintf(stdout, ""%s\n"", msg);",0.0,"fprintf(stdout, ""%s\n"", msg);",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* Signal - wrapper for the sigaction function,1.0,,* Signal - wrapper for the sigaction function,
*/,0.0,*/,,
"handler_t *Signal(int signum, handler_t *handler)",0.0,"handler_t *Signal(int signum, handler_t *handler)",,
{,0.0,{,,
"struct sigaction action, old_action;",0.0,"struct sigaction action, old_action;",,
,0.0,,,
action.sa_handler = handler;,0.0,action.sa_handler = handler;,,
sigemptyset(&action.sa_mask); /* block sigs of type being handled */,1.0,,sigemptyset(&action.sa_mask); /* block sigs of type being handled */,
action.sa_flags = SA_RESTART; /* restart syscalls if possible */,1.0,,action.sa_flags = SA_RESTART; /* restart syscalls if possible */,
,0.0,,,
"if (sigaction(signum, &action, &old_action) < 0)",0.0,"if (sigaction(signum, &action, &old_action) < 0)",,
"unix_error(""Signal error"");",0.0,"unix_error(""Signal error"");",,
return (old_action.sa_handler);,0.0,return (old_action.sa_handler);,,
},0.0,},,
,0.0,,,
/*,1.0,,/*,
* sigquit_handler - The driver program can gracefully terminate the,1.0,,* sigquit_handler - The driver program can gracefully terminate the,
*    child shell by sending it a SIGQUIT signal.,1.0,,*    child shell by sending it a SIGQUIT signal.,
*/,0.0,*/,,
void sigquit_handler(int sig),0.0,void sigquit_handler(int sig),,
{,0.0,{,,
"printf(""Terminating after receipt of SIGQUIT signal\n"");",0.0,"printf(""Terminating after receipt of SIGQUIT signal\n"");",,
exit(1);,0.0,exit(1);,,
},0.0,},,
,0.0,,,
,0.0,,,
,0.0,,,
